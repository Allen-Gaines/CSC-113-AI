<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Invaders — ChatGPT Prototype</title>
<style>
  :root{
    --bg:#000814;
    --panel:#001427;
    --accent:#00e5a8;
    --danger:#ff4d6d;
    --muted:#9aa6b2;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{
    display:flex;align-items:center;justify-content:center;
    background: radial-gradient(ellipse at center, #001021 0%, var(--bg) 60%);
    color:#e6f7f3;
  }

  /* Container */
  .wrap{
    width:980px; max-width:96vw;
    height:700px; max-height:86vh;
    background: linear-gradient(180deg,var(--panel), rgba(0,0,0,0.6));
    border:1px solid rgba(0,229,168,0.08);
    border-radius:10px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    position:relative; overflow:hidden;
  }

  canvas{display:block;background:transparent;width:100%;height:100%;}
  /* Top HUD */
  .hud{
    position:absolute;left:12px;top:12px;z-index:50;
    display:flex;gap:14px;align-items:center;
    background:var(--glass);padding:8px 12px;border-radius:8px;
    font-family:monospace;font-size:14px;color:var(--muted);
    border:1px solid rgba(255,255,255,0.02);
  }
  .hud span{color:var(--accent); margin-left:6px;}

  /* Center overlay screens */
  .overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    z-index:80;backdrop-filter: blur(2px);
  }
  .start, .gameover{
    background:linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.75));
    border-radius:12px;padding:28px 36px;text-align:center;border:1px solid rgba(0,229,168,0.05);
    color:#d7fff0; width:min(700px,90%);
  }
  .start h1{margin:0 0 8px;font-size:34px; color:var(--accent);letter-spacing:2px;}
  .start p{color:var(--muted); margin:10px 0 18px;}
  .btn{background:var(--accent); color:#001; border:none; padding:10px 18px; border-radius:8px; font-weight:700; cursor:pointer; font-size:16px;}
  .mutebtn{background:transparent;color:var(--muted); border:1px solid rgba(255,255,255,0.03);}
  .controls{display:flex;gap:12px;justify-content:center;margin-top:10px;}
  .small{font-size:13px;color:var(--muted);margin-top:8px;}

  /* responsive */
  @media (max-width:720px){
    .wrap{height:86vh;}
    .start h1{font-size:26px;}
  }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <canvas id="game"></canvas>

  <div class="hud" id="hud">
    Score: <span id="score">0</span>
    Lives: <span id="lives">3</span>
    Wave: <span id="wave">1</span>
    Invaders: <span id="invcount">0</span>
  </div>

  <!-- Start overlay -->
  <div class="overlay" id="startOverlay">
    <div class="start">
      <h1>SPACE INVADERS — ChatGPT Build</h1>
      <p>Classic arcade-style shooter: move left/right and shoot the descending alien fleet.</p>
      <div style="display:flex;gap:10px;justify-content:center;">
        <button class="btn" id="btnStart">Start Game</button>
        <button class="btn mutebtn" id="btnControls">Controls</button>
      </div>
      <div class="small" id="controlsText">Controls: ← → or A D to move • Space to shoot • Click to focus</div>
    </div>
  </div>

  <!-- Game over overlay -->
  <div class="overlay" id="gameOverOverlay" style="display:none">
    <div class="gameover">
      <h1 id="goTitle">Game Over</h1>
      <p id="goText">Final score: <strong id="finalScore">0</strong></p>
      <div style="display:flex;gap:10px;justify-content:center;">
        <button class="btn" id="btnRestart">Play Again</button>
        <button class="btn mutebtn" id="btnMenu">Back to Menu</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ===========================
   Space Invaders — ChatGPT
   Single-file prototype
   =========================== */

/* ---------- Canvas setup ---------- */
const canvas = document.getElementById('game');
const wrap = document.getElementById('wrap');
const ctx = canvas.getContext('2d', { alpha: true });

function resizeCanvas(){
  const rect = wrap.getBoundingClientRect();
  canvas.width = Math.floor(rect.width);
  canvas.height = Math.floor(rect.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Game state ---------- */
let state = {
  running: false,
  wave: 1,
  score: 0,
  lives: 3,
  invadersRemaining: 0,
  lastShot: 0,
  shotCooldown: 350, // ms
  lastTick: performance.now(),
  dt: 0
};

/* DOM bindings for HUD */
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const waveEl = document.getElementById('wave');
const invcountEl = document.getElementById('invcount');

/* ---------- Player ---------- */
const player = {
  w: 44, h: 18,
  x: 0, y: 0,
  speed: 420, // px/sec
  color: '#00e5a8',
  alive: true,
  bullets: []
};

function resetPlayer(){
  player.x = canvas.width/2 - player.w/2;
  player.y = canvas.height - 80;
  player.bullets = [];
  player.alive = true;
}

/* ---------- Invader fleet ---------- */
let fleet = {
  rows: 4,
  cols: 8,
  spacingX: 56,
  spacingY: 46,
  x: 80,
  y: 80,
  direction: 1, // 1 => right, -1 => left
  speedX: 26, // px per second (base)
  speedY: 18,
  margin: 20,
  list: []
};

/* Invader prototype */
function makeInvader(col,row,type=0){
  const size = 28;
  return {
    x: fleet.x + col * fleet.spacingX,
    y: fleet.y + row * fleet.spacingY,
    col,row,type,
    w: size, h: size,
    hp: type===2?3: (type===1?2:1),
    dead:false,
    baseColor: type===2? '#ffb86b' : (type===1? '#ffd166' : '#ff6b6b'),
    shootChance: 0.0014 // per frame base
  };
}

/* ---------- Barriers (shields) ---------- */
let shields = []; // array of {x,y,w,h,health}

/* ---------- Projectiles ----------
  We'll use two arrays: playerBullets and invaderBullets
*/
let invaderBullets = [];

/* ---------- Utility ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function now(){ return performance.now(); }

/* ---------- Initialize wave ---------- */
function spawnWave(n){
  fleet.list = [];
  const rows = clamp(3 + Math.floor(n/2), 3, 6);
  const cols = clamp(6 + Math.floor(n/2), 6, 12);
  fleet.rows = rows;
  fleet.cols = cols;
  fleet.x = 60;
  fleet.y = 70;
  fleet.direction = 1;
  fleet.speedX = 20 + n * 3; // increase with wave
  fleet.spacingX = Math.max(44, 56 - Math.floor(n/3));
  fleet.spacingY = 46;
  // create invaders: types vary by row
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      let type = 0;
      if(r===0 && rows>3) type = 2; // elite
      else if(r<=1) type = 1;
      fleet.list.push(makeInvader(c,r,type));
    }
  }
  state.invadersRemaining = fleet.list.length;
  state.wave = n;
  // reset shields
  createShields();
}

/* ---------- Create shields ---------- */
function createShields(){
  shields = [];
  const shieldCount = 4;
  const totalWidth = (shieldCount*80) + ((shieldCount-1)*40);
  let startX = canvas.width/2 - totalWidth/2;
  for(let i=0;i<shieldCount;i++){
    let sx = startX + i*(80+40);
    let sy = canvas.height - 180;
    // make shield as a small grid of blocks
    const blockW = 8, blockH = 6;
    let blocks = [];
    for(let by=0; by<10; by++){
      for(let bx=0; bx<10; bx++){
        // carve triangular hole to resemble invader shield
        if(by>6 && (bx<2 || bx>7)) continue;
        blocks.push({x: sx + bx*blockW, y: sy + by*blockH, w:blockW-1,h:blockH-1, hp:1});
      }
    }
    shields.push({blocks, x:sx, y:sy});
  }
}

/* ---------- Input ---------- */
const input = { left:false, right:false, shoot:false };
window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') input.left = true;
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') input.right = true;
  if(e.code==='Space') input.shoot = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') input.left = false;
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') input.right = false;
  if(e.code==='Space') input.shoot = false;
});

/* Mouse click focusing */
canvas.addEventListener('click', ()=> canvas.focus());

/* ---------- Collision helpers ---------- */
function rectIntersects(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* ---------- Spawn invader bullets randomly ---------- */
function invaderTryShoot(){
  // pick a few invaders to possibly shoot each tick
  for(let i=0;i<fleet.list.length;i++){
    if(Math.random() < (fleet.list[i].shootChance + state.wave*0.0002)){
      let inv = fleet.list[i];
      // invaders can only shoot if no other invader is directly below in same column (classic)
      let below = fleet.list.find(j => j.col === inv.col && j.row > inv.row && !j.dead);
      if(below) continue;
      // spawn bullet
      invaderBullets.push({
        x: inv.x + inv.w/2,
        y: inv.y + inv.h,
        w:3, h:10, speed: (120 + state.wave*18), color:'#ffba00'
      });
    }
  }
}

/* ---------- Game tick / update ---------- */
let tickAccumulator = 0;
function update(dt){
  // dt in seconds
  // Player movement
  const move = (input.left ? -1 : 0) + (input.right ? 1 : 0);
  player.x += move * player.speed * dt;
  player.x = clamp(player.x, 6, canvas.width - player.w - 6);

  // Shooting
  if(input.shoot && (now() - state.lastShot) > state.shotCooldown){
    firePlayerBullet();
    state.lastShot = now();
  }

  // Update player bullets
  for(let i=player.bullets.length-1;i>=0;i--){
    let b = player.bullets[i];
    b.y -= b.speed * dt;
    if(b.y + b.h < 0) player.bullets.splice(i,1);
  }

  // Update invader bullets
  for(let i=invaderBullets.length-1;i>=0;i--){
    let b = invaderBullets[i];
    b.y += b.speed * dt;
    if(b.y > canvas.height) { invaderBullets.splice(i,1); continue; }

    // Check collision with shields
    let hitShield = false;
    for(let s of shields){
      for(let bi = s.blocks.length-1; bi>=0; bi--){
        const block = s.blocks[bi];
        if(rectIntersects({x:b.x,y:b.y,w:b.w,h:b.h}, {x:block.x,y:block.y,w:block.w,h:block.h})){
          // damage block
          block.hp--;
          if(block.hp<=0) s.blocks.splice(bi,1);
          hitShield = true;
          break;
        }
      }
      if(hitShield) break;
    }
    if(hitShield){ invaderBullets.splice(i,1); continue; }

    // Check collision with player
    if(rectIntersects({x:b.x,y:b.y,w:b.w,h:b.h}, {x:player.x,y:player.y,w:player.w,h:player.h})){
      invaderBullets.splice(i,1);
      damagePlayer();
    }
  }

  // Update invaders movement: move horizontally; if hitting edge, move down and reverse.
  // Compute fleet bounds
  let leftMost = Infinity, rightMost = -Infinity, bottomMost = -Infinity;
  for(let inv of fleet.list){ if(inv.dead) continue; leftMost = Math.min(leftMost, inv.x); rightMost = Math.max(rightMost, inv.x + inv.w); bottomMost = Math.max(bottomMost, inv.y + inv.h); }
  if(leftMost===Infinity){ // no invaders
    // wave cleared
    state.wave++;
    state.score += 200; // small bonus
    spawnWave(state.wave);
  } else {
    const margin = 12;
    const speed = fleet.speedX;
    // approximate seconds move: dx = direction * speed * dt
    let dx = fleet.direction * speed * dt;
    // if after move it would go beyond canvas bounds, instead move down and flip
    if(rightMost + dx > canvas.width - margin || leftMost + dx < margin){
      // move down
      for(let inv of fleet.list){ inv.y += fleet.speedY; }
      fleet.direction *= -1;
      // speed up slightly
      fleet.speedX *= 1.04;
      // If invaders reached player's area => game over by invasion
      if(bottomMost + fleet.speedY > player.y - 20){
        endGame();
      }
    } else {
      // apply horizontal move
      for(let inv of fleet.list){ inv.x += dx; }
    }
  }

  // Random invader shooting
  if(Math.random() < 0.02) invaderTryShoot();

  // Player bullets vs invaders & shields
  for(let i=player.bullets.length-1;i>=0;i--){
    let b = player.bullets[i];
    // Check invaders
    let hit = false;
    for(let j=fleet.list.length-1;j>=0;j--){
      let inv = fleet.list[j];
      if(inv.dead) continue;
      if(rectIntersects({x:b.x,y:b.y,w:b.w,h:b.h}, {x:inv.x,y:inv.y,w:inv.w,h:inv.h})){
        inv.hp--;
        if(inv.hp<=0){
          inv.dead = true;
          state.score += 10 + (inv.type*10);
          state.invadersRemaining--;
        }
        // remove bullet
        player.bullets.splice(i,1);
        hit = true;
        break;
      }
    }
    if(hit) continue;

    // Check shields
    let shieldHit = false;
    for(let s of shields){
      for(let bi = s.blocks.length-1; bi>=0; bi--){
        const block = s.blocks[bi];
        if(rectIntersects({x:b.x,y:b.y,w:b.w,h:b.h}, {x:block.x,y:block.y,w:block.w,h:block.h})){
          block.hp--;
          if(block.hp<=0) s.blocks.splice(bi,1);
          shieldHit = true; break;
        }
      }
      if(shieldHit) break;
    }
    if(shieldHit){ player.bullets.splice(i,1); continue; }
  }

  // Remove dead invaders from list visually but keep their entries (we rely on dead flag)
  // Count remaining
  state.invadersRemaining = fleet.list.filter(i=>!i.dead).length;

  // Update HUD
  scoreEl.textContent = state.score;
  livesEl.textContent = state.lives;
  waveEl.textContent = state.wave;
  invcountEl.textContent = state.invadersRemaining;
}

/* ---------- firing ---------- */
function firePlayerBullet(){
  // limit bullets on screen
  if(player.bullets.length >= 3) return;
  const b = {
    x: player.x + player.w/2 - 3,
    y: player.y - 8,
    w:6, h:12, speed: 400, color:'#d1ffea'
  };
  player.bullets.push(b);
  // small visual/audio feedback
}

/* ---------- damage player ---------- */
function damagePlayer(){
  state.lives--;
  if(state.lives <= 0){
    endGame();
  } else {
    // reset player position, clear bullets
    resetPlayer();
    player.bullets = [];
    invaderBullets = [];
  }
}

/* ---------- draw ---------- */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // starfield
  drawStars();

  // draw shields
  for(let s of shields){
    for(let block of s.blocks){
      ctx.fillStyle = '#387b71';
      ctx.fillRect(block.x, block.y, block.w, block.h);
    }
  }

  // draw player
  ctx.fillStyle = player.color;
  roundRect(ctx, player.x, player.y, player.w, player.h, 4);
  // player gun
  ctx.fillRect(player.x + player.w/2 - 3, player.y - 10, 6, 8);

  // draw player bullets
  for(let b of player.bullets){
    ctx.fillStyle = b.color; ctx.fillRect(b.x,b.y,b.w,b.h);
  }

  // draw invaders
  for(let inv of fleet.list){
    if(inv.dead) continue;
    // simple sprite: three rows of pixels (blocky)
    ctx.fillStyle = inv.baseColor;
    ctx.fillRect(inv.x, inv.y, inv.w, inv.h);
    // simple eyes / detail
    ctx.fillStyle = '#001';
    ctx.fillRect(inv.x + inv.w*0.25, inv.y + inv.h*0.2, inv.w*0.18, inv.h*0.12);
    ctx.fillRect(inv.x + inv.w*0.6, inv.y + inv.h*0.2, inv.w*0.18, inv.h*0.12);
    // hp bar tiny
    if(inv.hp < (inv.type===2?3: (inv.type===1?2:1))){
      ctx.fillStyle = '#ff4040';
      ctx.fillRect(inv.x, inv.y - 6, (inv.w) * (inv.hp / (inv.type===2?3:(inv.type===1?2:1))), 4);
    }
  }

  // draw invader bullets
  for(let b of invaderBullets){
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // HUD bottom small instructions
  ctx.font = '13px monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillText('Move: ← → or A D   |   Shoot: Space', 16, canvas.height - 12);
}

/* ---------- starfield helper ---------- */
function drawStars(){
  // we can render deterministic stars based on canvas size
  ctx.fillStyle = '#ffffff';
  const count = Math.floor((canvas.width*canvas.height)/22000);
  for(let i=0;i<count;i++){
    // pseudo-random by index for stability
    const x = (i * 97) % canvas.width;
    const y = (i * 61) % canvas.height;
    ctx.fillRect(x, y, 1, 1);
  }
}

/* ---------- Utility: rounded rect ---------- */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
}

/* ---------- Game flow ---------- */
let rafId = null;
function gameLoop(t){
  const dt = Math.min(0.05, (t - state.lastTick) / 1000); // clamp dt
  state.lastTick = t;
  update(dt);
  draw();
  if(state.running) rafId = requestAnimationFrame(gameLoop);
}

/* ---------- start / end ---------- */
const startOverlay = document.getElementById('startOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');
const btnMenu = document.getElementById('btnMenu');
const finalScore = document.getElementById('finalScore');

btnStart.addEventListener('click', ()=>{
  startOverlay.style.display = 'none';
  beginGame();
});
btnRestart.addEventListener('click', ()=>{
  gameOverOverlay.style.display = 'none';
  beginGame();
});
btnMenu.addEventListener('click', ()=>{
  gameOverOverlay.style.display = 'none';
  startOverlay.style.display = 'flex';
});

function beginGame(){
  // reset state
  state.running = true;
  state.score = 0;
  state.wave = 1;
  state.lives = 3;
  state.lastShot = 0;
  state.lastTick = performance.now();
  state.shotCooldown = 300;
  player.speed = 420;
  resetPlayer();
  spawnWave(1);
  if(rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(gameLoop);
}

function endGame(){
  state.running = false;
  finalScore.textContent = state.score;
  gameOverOverlay.style.display = 'flex';
  // stop game loop
  if(rafId) cancelAnimationFrame(rafId);
}

/* ---------- initial setup ---------- */
resetPlayer();
spawnWave(1);

/* make player dims known */
player.w = 48;
player.h = 16;

/* expose a simple debug-ish control (muted) if desired */
// focus on canvas to catch keyboard
canvas.setAttribute('tabindex', '0');
canvas.style.outline = 'none';

/* Make click on wrap focus and optionally start controls overlay */
document.getElementById('btnControls').addEventListener('click', ()=>{
  const ct = document.getElementById('controlsText');
  ct.innerHTML = 'Controls: ← → or A D to move • Space to shoot • Click canvas to focus • Shields block projectiles';
});

/* small adaptive touch support: on-screen buttons for tiny screens */
if(window.innerWidth < 520){
  // show tiny control hints (we keep it simple)
  document.getElementById('controlsText').textContent = 'Tap canvas then use on-screen keys (not implemented) — physical keyboard recommended on mobile.';
}

/* prevent the browser from scrolling on spacebar */
window.addEventListener('keydown', (e)=>{
  if(e.code === 'Space' && (document.activeElement === document.body || document.activeElement === canvas)) {
    e.preventDefault();
  }
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense Command</title><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense Command</title><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense Command</title>
    <style>
        :root {
            --primary: #00ff88;
            --primary-dark: #00cc6a;
            --danger: #ff4444;
            --warning: #ffaa00;
            --bg-dark: #0a0a1a;
            --bg-panel: rgba(0, 20, 40, 0.85);
            --text: #ffffff;
            --glow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 2px solid var(--primary);
            border-radius: 10px;
            box-shadow: var(--glow), inset 0 0 50px rgba(0, 255, 136, 0.1);
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            border-radius: 8px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--bg-panel);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
        }

        .stat {
            margin: 8px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: #aaa;
            min-width: 90px;
        }

        .stat-value {
            color: var(--primary);
            font-weight: bold;
            font-size: 16px;
        }

        .stat-value.danger {
            color: var(--danger);
        }

        .stat-value.warning {
            color: var(--warning);
        }

        #costPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--bg-panel);
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        #costPanel.can-afford {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        #costPanel.cannot-afford {
            border-color: var(--danger);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }

        .cost-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .cost-value {
            font-size: 20px;
            font-weight: bold;
        }

        #turretSelect {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        .turret-option {
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .turret-option:hover {
            border-color: #888;
            transform: translateY(-2px);
        }

        .turret-option.selected {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .turret-option.cannot-afford {
            opacity: 0.5;
        }

        .turret-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
        }

        .turret-info {
            text-align: left;
        }

        .turret-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }

        .turret-cost {
            font-size: 10px;
            color: #aaa;
        }

        #controlPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        #controlPanel button {
            background: var(--bg-panel);
            color: var(--text);
            border: 2px solid #444;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #controlPanel button:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        #controlPanel button.active {
            border-color: var(--warning);
            background: rgba(255, 170, 0, 0.2);
        }

        #controlPanel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #nukeBtn {
            border-color: #ff4444;
        }

        #nukeBtn:hover:not(:disabled) {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff6666;
        }

        #freezeBtn {
            border-color: #44aaff;
        }

        #freezeBtn:hover:not(:disabled) {
            background: rgba(68, 170, 255, 0.2);
            border-color: #66ccff;
        }

        .boss-warning {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            color: #ff0066;
            text-shadow: 0 0 20px #ff0066;
            z-index: 55;
            animation: bossWarn 0.5s ease-in-out infinite;
        }

        @keyframes bossWarn {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .freeze-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(68, 170, 255, 0.2);
            pointer-events: none;
            z-index: 45;
            animation: freezeFade 3s ease-out forwards;
        }

        @keyframes freezeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .nuke-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 45;
            animation: nukeFade 0.5s ease-out forwards;
        }

        @keyframes nukeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #upgradePanel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            display: none;
            text-align: center;
        }

        #upgradePanel h3 {
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 14px;
        }

        #upgradePanel .stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 10px;
        }

        .upgrade-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #upgradePanel button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        #upgradePanel button:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        #upgradePanel button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen, #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #gameOver {
            display: none;
        }

        #startScreen h1, #gameOver h1 {
            font-size: 48px;
            color: var(--primary);
            margin-bottom: 10px;
            text-shadow: var(--glow);
            letter-spacing: 3px;
        }

        #startScreen p, #gameOver p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 16px;
        }

        #startScreen button, #gameOver button {
            font-size: 20px;
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
        }

        #startScreen button:hover, #gameOver button:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
            box-shadow: var(--glow);
        }

        #instructions {
            margin-top: 30px;
            max-width: 400px;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 12px 0;
            text-align: left;
            color: #ccc;
        }

        .instruction-item .icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }

        #finalScore, #wavesSurvived {
            color: var(--primary);
            font-size: 24px;
        }

        .popup-message {
            position: absolute;
            background: var(--bg-panel);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--primary);
            color: var(--text);
            font-size: 14px;
            pointer-events: none;
            animation: fadeUp 1.5s ease-out forwards;
            z-index: 50;
        }

        .popup-message.error {
            border-color: var(--danger);
            color: var(--danger);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .wave-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--primary);
            text-shadow: var(--glow);
            z-index: 50;
            animation: waveAnnounce 2s ease-out forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #waveBreak {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            padding: 25px 40px;
            border-radius: 15px;
            border: 2px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 60;
            text-align: center;
        }

        #waveBreak h2 {
            color: var(--primary);
            margin-bottom: 15px;
            text-shadow: var(--glow);
        }

        .break-timer {
            font-size: 18px;
            margin: 15px 0;
            color: #ccc;
        }

        .timer-num {
            font-size: 48px;
            font-weight: bold;
            color: var(--primary);
            display: block;
            margin: 10px 0;
            text-shadow: var(--glow);
        }

        .break-info {
            margin: 15px 0;
            color: #aaa;
        }

        .break-info .hint {
            color: var(--warning);
            font-weight: bold;
            margin-top: 8px;
        }

        #waveBreak button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            margin-top: 10px;
        }

        #waveBreak button:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div id="ui">
            <div class="stat">
                <span class="stat-label">Wave:</span>
                <span class="stat-value" id="wave">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Score:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Resources:</span>
                <span class="stat-value" id="resources">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Base Health:</span>
                <span class="stat-value" id="baseHealth">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Enemies:</span>
                <span class="stat-value" id="enemiesLeft">0</span>
            </div>
        </div>

        <div id="costPanel" class="can-afford">
            <div class="cost-label">SELECTED TURRET</div>
            <div class="cost-value" id="selectedTurretName">üíé 50</div>
        </div>

        <div id="turretSelect">
            <div class="turret-option selected" data-type="basic" onclick="selectTurretType('basic')">
                <div class="turret-icon" style="background: #00ff88;">B</div>
                <div class="turret-info">
                    <div class="turret-name">Basic</div>
                    <div class="turret-cost">50 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="rapid" onclick="selectTurretType('rapid')">
                <div class="turret-icon" style="background: #00ccff;">R</div>
                <div class="turret-info">
                    <div class="turret-name">Rapid</div>
                    <div class="turret-cost">75 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="cannon" onclick="selectTurretType('cannon')">
                <div class="turret-icon" style="background: #ff8800;">C</div>
                <div class="turret-info">
                    <div class="turret-name">Cannon</div>
                    <div class="turret-cost">100 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="slow" onclick="selectTurretType('slow')">
                <div class="turret-icon" style="background: #aa44ff;">S</div>
                <div class="turret-info">
                    <div class="turret-name">Slow</div>
                    <div class="turret-cost">60 üíé</div>
                </div>
            </div>
        </div>

        <div id="controlPanel">
            <button id="fastForwardBtn" onclick="toggleFastForward()">‚ñ∂‚ñ∂ 1x</button>
            <button id="nukeBtn" onclick="useNuke()">üí• Nuke (200üíé)</button>
            <button id="freezeBtn" onclick="useFreeze()">‚ùÑÔ∏è Freeze (100üíé)</button>
        </div>

        <div id="upgradePanel">
            <h3>‚öôÔ∏è TURRET OPTIONS</h3>
            <div class="stats" id="turretStats"></div>
            <div class="upgrade-buttons">
                <button id="upgradeBtn" onclick="upgradeTurret()">Upgrade (75 üíé)</button>
                <button id="sellBtn" onclick="sellTurret()" style="background: #ff4444;">Sell (+25 üíé)</button>
                <button onclick="closeUpgradePanel()" style="background: #444; color: #fff;">Close</button>
            </div>
        </div>

        <div id="waveBreak">
            <div class="break-content">
                <h2>‚ö° WAVE CLEARED!</h2>
                <div class="break-timer">
                    <span>Next wave in:</span>
                    <span id="breakTimer" class="timer-num">10</span>
                    <span>seconds</span>
                </div>
                <div class="break-info">
                    <p>Wave <span id="nextWaveNum">2</span> incoming: <span id="nextEnemyCount">9</span> enemies</p>
                    <p class="hint">Place turrets & upgrade now!</p>
                </div>
                <button onclick="skipBreak()">START NOW ‚Üí</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>SPACE DEFENSE COMMAND</h1>
            <p>Place turrets, defend your base, survive the alien invasion</p>
            <button onclick="startGame()">LAUNCH DEFENSE</button>
            <div id="instructions">
                <div class="instruction-item">
                    <div class="icon">üéØ</div>
                    <div>4 turret types: Basic, Rapid, Cannon, Slow</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üëæ</div>
                    <div>Enemy types: Normal, Scout (fast), Tank (tough), BOSS!</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üí•</div>
                    <div>Special abilities: Nuke (200üíé) & Freeze (100üíé)</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">‚ö†Ô∏è</div>
                    <div>Boss every 5 waves - prepare your defense!</div>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h1>DEFENSE BREACHED</h1>
            <p>Your base has fallen to the alien invasion</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="wavesSurvived">0</span></p>
            <button onclick="restartGame()">REDEPLOY DEFENSES</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            resources: 100,
            wave: 1,
            baseHealth: 100,
            gameOver: false,
            waveSpawning: false
        };

        // Game objects
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let stars = [];
        let selectedTurret = null;

        // Base position (right side)
        const base = {
            x: canvas.width - 60,
            y: canvas.height / 2,
            width: 80,
            height: 120
        };

        // Initialize starfield
        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random()
                });
            }
        }

        // Turret types configuration
        const turretTypes = {
            basic: {
                name: 'Basic',
                cost: 50,
                color: '#00ff88',
                colorDark: '#00cc6a',
                baseRange: 150,
                baseDamage: 25,
                baseFireRate: 800,
                description: 'Balanced turret'
            },
            rapid: {
                name: 'Rapid',
                cost: 75,
                color: '#00ccff',
                colorDark: '#0099cc',
                baseRange: 120,
                baseDamage: 10,
                baseFireRate: 250,
                description: 'Fast shots, low damage'
            },
            cannon: {
                name: 'Cannon',
                cost: 100,
                color: '#ff8800',
                colorDark: '#cc6600',
                baseRange: 180,
                baseDamage: 60,
                baseFireRate: 1500,
                splash: 40,
                description: 'Slow, high damage, splash'
            },
            slow: {
                name: 'Slow',
                cost: 60,
                color: '#aa44ff',
                colorDark: '#7722cc',
                baseRange: 130,
                baseDamage: 5,
                baseFireRate: 600,
                slowAmount: 0.5,
                slowDuration: 2000,
                description: 'Slows enemies down'
            }
        };

        let selectedTurretType = 'basic';

        // Turret class with upgrade system
        class Turret {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = turretTypes[type];
                this.level = 1;
                this.maxLevel = 3;
                this.baseRange = this.config.baseRange;
                this.baseDamage = this.config.baseDamage;
                this.baseFireRate = this.config.baseFireRate;
                this.splash = this.config.splash || 0;
                this.updateStats();
                this.lastShot = 0;
                this.target = null;
                this.angle = 0;
            }

            getSellValue() {
                // 50% of total invested (base cost + upgrade costs)
                let totalInvested = this.config.cost;
                for (let i = 1; i < this.level; i++) {
                    totalInvested += 50 + i * 25;
                }
                return Math.floor(totalInvested * 0.5);
            }

            updateStats() {
                this.range = this.baseRange + (this.level - 1) * 40;
                this.damage = this.baseDamage + (this.level - 1) * 15;
                this.fireRate = Math.max(300, this.baseFireRate - (this.level - 1) * 200);
            }

            getUpgradeCost() {
                return this.level < this.maxLevel ? 50 + this.level * 25 : null;
            }

            upgrade() {
                if (this.level < this.maxLevel) {
                    this.level++;
                    this.updateStats();
                    return true;
                }
                return false;
            }

            findTarget() {
                let closest = null;
                let closestDist = this.range;
                
                for (let enemy of enemies) {
                    let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = enemy;
                    }
                }
                this.target = closest;
            }

            update(currentTime) {
                this.findTarget();
                
                if (this.target) {
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    
                    // Adjust fire rate by game speed
                    let adjustedFireRate = this.fireRate / gameSpeed;
                    if (currentTime - this.lastShot > adjustedFireRate) {
                        projectiles.push(new Projectile(this.x, this.y, this.target, this.damage, this.level, this.type));
                        this.lastShot = currentTime;
                    }
                }
            }

            draw() {
                // Range indicator when selected
                if (selectedTurret === this) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.05)';
                    ctx.fill();
                }

                // Use turret type colors
                const color = {
                    main: this.config.color,
                    dark: this.config.colorDark
                };

                // Turret base
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 25);
                gradient.addColorStop(0, color.main);
                gradient.addColorStop(0.7, color.dark);
                gradient.addColorStop(1, '#004433');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 22 + this.level * 2, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.strokeStyle = color.main;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6 + this.level, 0, Math.PI * 2);
                ctx.fill();

                // Barrel - different style per type
                ctx.strokeStyle = color.main;
                ctx.lineWidth = this.type === 'cannon' ? 10 + this.level * 2 : 6 + this.level * 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * (28 + this.level * 4),
                    this.y + Math.sin(this.angle) * (28 + this.level * 4)
                );
                ctx.stroke();

                // Barrel highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Level indicator
                ctx.fillStyle = color.main;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚òÖ'.repeat(this.level), this.x, this.y + 35);
                
                // Type indicator
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = 'bold 8px sans-serif';
                ctx.fillText(this.config.name.toUpperCase(), this.x, this.y - 30);
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target, damage, level = 1, turretType = 'basic') {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.level = level;
                this.turretType = turretType;
                // Rapid is faster, cannon is slower
                if (turretType === 'rapid') {
                    this.speed = 8 + level;
                } else if (turretType === 'cannon') {
                    this.speed = 3 + level * 0.5;
                } else if (turretType === 'slow') {
                    this.speed = 6 + level;
                } else {
                    this.speed = 4 + level;
                }
                this.homing = 0.12;
                this.trail = [];
                this.splash = turretType === 'cannon' ? 40 + level * 10 : 0;
                
                // Slow effect properties
                if (turretType === 'slow') {
                    this.slowAmount = 0.5 - (level - 1) * 0.1; // Level 1: 50%, Level 2: 40%, Level 3: 30%
                    this.slowDuration = 2000 + (level - 1) * 500;
                }
            }

            update() {
                if (!this.target || !enemies.includes(this.target)) {
                    return false;
                }

                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) this.trail.shift();

                // Homing
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist < 15) {
                    this.target.health -= this.damage;
                    
                    // Apply slow effect
                    if (this.turretType === 'slow') {
                        this.target.applySlow(this.slowAmount, this.slowDuration);
                    }
                    
                    // Splash damage for cannon
                    if (this.splash > 0) {
                        for (let enemy of enemies) {
                            if (enemy !== this.target) {
                                let splashDist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                if (splashDist < this.splash) {
                                    enemy.health -= this.damage * 0.5;
                                }
                            }
                        }
                        createExplosion(this.x, this.y, 3);
                    } else {
                        createExplosion(this.x, this.y, this.level);
                    }
                    return false;
                }

                this.x += (dx / dist) * this.speed * gameSpeed;
                this.y += (dy / dist) * this.speed * gameSpeed;
                return true;
            }

            draw() {
                // Trail
                const trailColors = {
                    basic: '#00ff88',
                    rapid: '#00ccff', 
                    cannon: '#ff8800',
                    slow: '#aa44ff'
                };
                
                for (let i = 0; i < this.trail.length; i++) {
                    let alpha = i / this.trail.length * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = trailColors[this.turretType];
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, this.turretType === 'cannon' ? 4 : 2 + this.level, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Main projectile
                ctx.fillStyle = trailColors[this.turretType];
                ctx.shadowColor = trailColors[this.turretType];
                ctx.shadowBlur = 10;
                ctx.beginPath();
                let size = this.turretType === 'cannon' ? 6 + this.level : 4 + this.level;
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Enemy types configuration
        const enemyTypes = {
            scout: {
                name: 'Scout',
                color: '#ffff00',
                colorDark: '#cccc00',
                speedMult: 2.0,
                healthMult: 0.4,
                sizeMult: 0.7,
                valueMult: 0.8
            },
            normal: {
                name: 'Normal',
                color: '#ff6666',
                colorDark: '#cc3333',
                speedMult: 1.0,
                healthMult: 1.0,
                sizeMult: 1.0,
                valueMult: 1.0
            },
            tank: {
                name: 'Tank',
                color: '#aa44ff',
                colorDark: '#7722cc',
                speedMult: 0.5,
                healthMult: 2.5,
                sizeMult: 1.4,
                valueMult: 2.0
            },
            boss: {
                name: 'BOSS',
                color: '#ff0066',
                colorDark: '#cc0044',
                speedMult: 0.3,
                healthMult: 10.0,
                sizeMult: 2.0,
                valueMult: 10.0
            }
        };

        // Game speed multiplier
        let gameSpeed = 1;

        // Single lane for enemy path
        const lane = 350;  // Center of screen

        // Enemy class
        class Enemy {
            constructor(wave, type = 'normal') {
                this.x = -30;
                this.y = lane;
                this.type = type;
                this.config = enemyTypes[type];
                
                // Base stats modified by type
                let baseSpeed = 0.4 + wave * 0.08;
                let baseHealth = 40 + wave * 15;
                let baseSize = 18 + Math.min(wave, 10);
                let baseValue = 10 + wave * 3;
                
                this.baseSpeed = baseSpeed * this.config.speedMult;
                this.speed = this.baseSpeed + Math.random() * 0.1;
                this.maxHealth = Math.floor(baseHealth * this.config.healthMult);
                this.health = this.maxHealth;
                this.size = Math.floor(baseSize * this.config.sizeMult);
                this.value = Math.floor(baseValue * this.config.valueMult);
                
                // Slow effect
                this.slowedUntil = 0;
                this.slowAmount = 1;
            }

            applySlow(amount, duration) {
                this.slowAmount = amount;
                this.slowedUntil = Date.now() + duration;
            }

            update() {
                // Check if slow expired
                if (Date.now() > this.slowedUntil) {
                    this.slowAmount = 1;
                }
                
                // Apply speed with slow effect and game speed
                let currentSpeed = this.speed * this.slowAmount * gameSpeed;
                
                // Straight horizontal path toward base - strict lane movement
                this.x += currentSpeed;
                // Keep Y position locked to lane
                this.y = lane;

                // Check if reached base
                if (this.x > base.x - 40) {
                    gameState.baseHealth -= 10;
                    updateUI();
                    return false;
                }

                // Check if dead
                if (this.health <= 0) {
                    gameState.score += this.value;
                    gameState.resources += Math.floor(this.value / 2);
                    createExplosion(this.x, this.y, 2);
                    updateUI();
                    return false;
                }

                return true;
            }

            draw() {
                // Slow effect indicator
                if (this.slowAmount < 1) {
                    ctx.strokeStyle = 'rgba(170, 68, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enemy body - use type colors
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.config.color);
                gradient.addColorStop(0.5, this.config.colorDark);
                gradient.addColorStop(1, '#220000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Spikes - different count per type
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = this.type === 'tank' || this.type === 'boss' ? 4 : 3;
                let spikeCount = this.type === 'scout' ? 4 : this.type === 'boss' ? 12 : this.type === 'tank' ? 8 : 6;
                for (let i = 0; i < spikeCount; i++) {
                    let angle = (i / spikeCount) * Math.PI * 2 + Date.now() / 1000;
                    let spikeLength = this.type === 'boss' ? 15 : 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * this.size, this.y + Math.sin(angle) * this.size);
                    ctx.lineTo(this.x + Math.cos(angle) * (this.size + spikeLength), this.y + Math.sin(angle) * (this.size + spikeLength));
                    ctx.stroke();
                }

                // Health bar
                let healthPercent = this.health / this.maxHealth;
                let barWidth = this.size * 2;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth, 6);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffaa00' : '#ff4444';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth * healthPercent, 6);
                
                // Type label for tanks and bosses
                if (this.type === 'tank' || this.type === 'boss') {
                    ctx.fillStyle = this.type === 'boss' ? '#ff0066' : 'rgba(255,255,255,0.7)';
                    ctx.font = this.type === 'boss' ? 'bold 12px sans-serif' : 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.type.toUpperCase(), this.x, this.y - this.size - 16);
                }
                
                // Boss glow effect
                if (this.type === 'boss') {
                    ctx.strokeStyle = `rgba(255, 0, 102, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx * gameSpeed;
                this.y += this.vy * gameSpeed;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life -= gameSpeed;
                return this.life > 0;
            }

            draw() {
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createExplosion(x, y, intensity = 1) {
            const colors = ['rgb(255, 136, 0)', 'rgb(255, 200, 0)', 'rgb(255, 68, 68)', 'rgb(255, 255, 255)'];
            for (let i = 0; i < 8 * intensity; i++) {
                particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function spawnWave() {
            // Wave 1 = 4 enemies, then +5 per wave (wave 2 = 9, wave 3 = 14, etc.)
            let enemyCount = 4 + (gameState.wave - 1) * 5;
            gameState.waveSpawning = true;
            
            // Boss wave every 5 waves
            let isBossWave = gameState.wave % 5 === 0;
            
            for (let i = 0; i < enemyCount; i++) {
                // Determine enemy type based on wave and randomness
                let type = 'normal';
                let roll = Math.random();
                
                // Scouts appear from wave 2+
                if (gameState.wave >= 2 && roll < 0.3) {
                    type = 'scout';
                }
                // Tanks appear from wave 3+
                else if (gameState.wave >= 3 && roll > 0.85) {
                    type = 'tank';
                }
                
                // Slower spawn rate - more time between enemies
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, type));
                    }
                    // Mark spawning complete after last enemy
                    if (i === enemyCount - 1) {
                        gameState.waveSpawning = false;
                    }
                }, i * (1200 - Math.min(gameState.wave * 40, 600)));
            }
            
            // Spawn boss at the end of boss waves
            if (isBossWave) {
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, 'boss'));
                        showBossWarning();
                    }
                }, enemyCount * (1200 - Math.min(gameState.wave * 40, 600)) + 1000);
            }
            
            showWaveAnnouncement(isBossWave);
        }
        
        function showBossWarning() {
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.textContent = '‚ö†Ô∏è BOSS INCOMING! ‚ö†Ô∏è';
            document.getElementById('gameContainer').appendChild(warning);
            setTimeout(() => warning.remove(), 2000);
        }

        let waveBreakTimer = null;
        let breakTimeLeft = 0;

        function startWaveBreak() {
            breakTimeLeft = 10;
            updateBreakDisplay();
            document.getElementById('waveBreak').style.display = 'flex';
            
            waveBreakTimer = setInterval(() => {
                breakTimeLeft--;
                updateBreakDisplay();
                
                if (breakTimeLeft <= 0) {
                    clearInterval(waveBreakTimer);
                    document.getElementById('waveBreak').style.display = 'none';
                    gameState.wave++;
                    spawnWave();
                }
            }, 1000);
        }

        function updateBreakDisplay() {
            document.getElementById('breakTimer').textContent = breakTimeLeft;
            document.getElementById('nextWaveNum').textContent = gameState.wave + 1;
            // Show how many enemies next wave
            let nextEnemyCount = 4 + gameState.wave * 5;
            document.getElementById('nextEnemyCount').textContent = nextEnemyCount;
        }

        function skipBreak() {
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
                document.getElementById('waveBreak').style.display = 'none';
                gameState.wave++;
                spawnWave();
            }
        }

        function showWaveAnnouncement(isBossWave = false) {
            const announcement = document.createElement('div');
            announcement.className = 'wave-announcement';
            if (isBossWave) {
                announcement.innerHTML = `WAVE ${gameState.wave}<br><span style="color: #ff0066; font-size: 24px;">‚ö†Ô∏è BOSS WAVE ‚ö†Ô∏è</span>`;
            } else {
                announcement.textContent = `WAVE ${gameState.wave}`;
            }
            document.getElementById('gameContainer').appendChild(announcement);
            setTimeout(() => announcement.remove(), 2000);
        }

        function showPopup(x, y, message, isError = false) {
            const popup = document.createElement('div');
            popup.className = 'popup-message' + (isError ? ' error' : '');
            popup.textContent = message;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        function handleClick(e) {
            if (!gameState.isPlaying || gameState.gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicked on existing turret
            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 30) {
                    selectedTurret = turret;
                    showUpgradePanel(turret);
                    return;
                }
            }

            // Close upgrade panel if clicking elsewhere
            closeUpgradePanel();

            // Check placement validity
            if (x > canvas.width - 150) {
                showPopup(x, y - 20, "Too close to base!", true);
                return;
            }

            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 60) {
                    showPopup(x, y - 20, "Too close to turret!", true);
                    return;
                }
            }

            if (gameState.resources >= turretTypes[selectedTurretType].cost) {
                turrets.push(new Turret(x, y, selectedTurretType));
                gameState.resources -= turretTypes[selectedTurretType].cost;
                showPopup(x, y - 20, `${turretTypes[selectedTurretType].name} deployed!`);
                updateUI();
            } else {
                showPopup(x, y - 20, `Need ${turretTypes[selectedTurretType].cost} resources!`, true);
            }
        }

        function selectTurretType(type) {
            selectedTurretType = type;
            // Update UI
            document.querySelectorAll('.turret-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.type === type) {
                    opt.classList.add('selected');
                }
            });
            updateUI();
        }

        function showUpgradePanel(turret) {
            const panel = document.getElementById('upgradePanel');
            const stats = document.getElementById('turretStats');
            const btn = document.getElementById('upgradeBtn');
            const sellBtn = document.getElementById('sellBtn');
            
            stats.innerHTML = `${turret.config.name} Lv${turret.level}/${turret.maxLevel} | DMG: ${turret.damage} | Range: ${turret.range}`;
            
            const cost = turret.getUpgradeCost();
            if (cost) {
                btn.textContent = `Upgrade (${cost} üíé)`;
                btn.disabled = gameState.resources < cost;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
            
            // Sell button
            const sellValue = turret.getSellValue();
            sellBtn.textContent = `Sell (+${sellValue} üíé)`;
            
            panel.style.display = 'flex';
        }

        function sellTurret() {
            if (!selectedTurret) return;
            
            const sellValue = selectedTurret.getSellValue();
            gameState.resources += sellValue;
            
            // Remove turret from array
            const index = turrets.indexOf(selectedTurret);
            if (index > -1) {
                turrets.splice(index, 1);
            }
            
            showPopup(selectedTurret.x, selectedTurret.y - 30, `Sold for ${sellValue} üíé`);
            closeUpgradePanel();
            updateUI();
        }

        function toggleFastForward() {
            if (gameSpeed === 1) {
                gameSpeed = 2;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 2x';
                document.getElementById('fastForwardBtn').classList.add('active');
            } else {
                gameSpeed = 1;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
                document.getElementById('fastForwardBtn').classList.remove('active');
            }
        }

        function useNuke() {
            if (gameState.resources < 200 || enemies.length === 0) return;
            
            gameState.resources -= 200;
            
            // Damage all enemies
            for (let enemy of enemies) {
                enemy.health -= 100;
                createExplosion(enemy.x, enemy.y, 2);
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'nuke-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 500);
            
            showPopup(canvas.width / 2, canvas.height / 2, 'üí• NUKE ACTIVATED!');
            updateUI();
        }

        function useFreeze() {
            if (gameState.resources < 100 || enemies.length === 0) return;
            
            gameState.resources -= 100;
            
            // Freeze all enemies for 3 seconds
            for (let enemy of enemies) {
                enemy.applySlow(0, 3000); // 0 = completely stopped
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'freeze-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 3000);
            
            showPopup(canvas.width / 2, canvas.height / 2, '‚ùÑÔ∏è FREEZE ACTIVATED!');
            updateUI();
        }

        function closeUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            selectedTurret = null;
        }

        function upgradeTurret() {
            if (!selectedTurret) return;
            
            const cost = selectedTurret.getUpgradeCost();
            if (cost && gameState.resources >= cost) {
                gameState.resources -= cost;
                selectedTurret.upgrade();
                showPopup(selectedTurret.x, selectedTurret.y - 30, `Upgraded to Level ${selectedTurret.level}!`);
                showUpgradePanel(selectedTurret);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('resources').textContent = gameState.resources;
            document.getElementById('baseHealth').textContent = gameState.baseHealth;
            document.getElementById('enemiesLeft').textContent = enemies.length;

            // Health color
            const healthEl = document.getElementById('baseHealth');
            healthEl.className = 'stat-value';
            if (gameState.baseHealth <= 25) healthEl.classList.add('danger');
            else if (gameState.baseHealth <= 50) healthEl.classList.add('warning');

            // Cost panel - show selected turret
            const costPanel = document.getElementById('costPanel');
            const selectedConfig = turretTypes[selectedTurretType];
            document.getElementById('selectedTurretName').textContent = `${selectedConfig.name} - ${selectedConfig.cost} üíé`;
            costPanel.className = gameState.resources >= selectedConfig.cost ? 'can-afford' : 'cannot-afford';
            
            // Update turret selection buttons affordability
            document.querySelectorAll('.turret-option').forEach(opt => {
                const type = opt.dataset.type;
                const cost = turretTypes[type].cost;
                if (gameState.resources < cost) {
                    opt.classList.add('cannot-afford');
                } else {
                    opt.classList.remove('cannot-afford');
                }
            });
            
            // Update ability buttons
            document.getElementById('nukeBtn').disabled = gameState.resources < 200;
            document.getElementById('freezeBtn').disabled = gameState.resources < 100;
        }

        function drawStars() {
            for (let star of stars) {
                star.x -= star.speed;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
                
                let twinkle = 0.5 + Math.sin(Date.now() / 500 + star.brightness * 10) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLanes() {
            // Draw single lane path so player knows where enemies will travel
            let y = lane;
            
            // Lane background stripe
            ctx.fillStyle = 'rgba(255, 100, 100, 0.08)';
            ctx.fillRect(0, y - 30, canvas.width - 100, 60);
            
            // Lane guide line (dashed)
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.25)';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width - 100, y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Lane edges
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y - 30);
            ctx.lineTo(canvas.width - 100, y - 30);
            ctx.moveTo(0, y + 30);
            ctx.lineTo(canvas.width - 100, y + 30);
            ctx.stroke();
        }

        function drawBase() {
            // Base glow
            const glow = ctx.createRadialGradient(base.x, base.y, 0, base.x, base.y, 80);
            glow.addColorStop(0, 'rgba(0, 136, 255, 0.3)');
            glow.addColorStop(1, 'rgba(0, 136, 255, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 80, 0, Math.PI * 2);
            ctx.fill();

            // Base structure
            const gradient = ctx.createLinearGradient(base.x - 40, 0, base.x + 40, 0);
            gradient.addColorStop(0, '#0066aa');
            gradient.addColorStop(0.5, '#0088ff');
            gradient.addColorStop(1, '#0066aa');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(base.x - 30, base.y + 50);
            ctx.lineTo(base.x - 40, base.y);
            ctx.lineTo(base.x - 30, base.y - 50);
            ctx.lineTo(base.x + 20, base.y - 40);
            ctx.lineTo(base.x + 30, base.y);
            ctx.lineTo(base.x + 20, base.y + 40);
            ctx.closePath();
            ctx.fill();

            // Shield effect
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.3 + Math.sin(Date.now() / 300) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 55, 0, Math.PI * 2);
            ctx.stroke();

            // Health indicator
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', base.x, base.y + 70);
        }

        function gameLoop(timestamp) {
            // Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Background
            drawStars();
            drawLanes();

            if (gameState.isPlaying && !gameState.gameOver) {
                // Update
                turrets.forEach(t => t.update(timestamp));
                projectiles = projectiles.filter(p => p.update());
                enemies = enemies.filter(e => e.update());
                particles = particles.filter(p => p.update());

                // Check wave complete - start break timer instead of immediate spawn
                if (enemies.length === 0 && gameState.isPlaying && !gameState.waveSpawning && document.getElementById('waveBreak').style.display !== 'flex') {
                    startWaveBreak();
                }

                // Check game over
                if (gameState.baseHealth <= 0) {
                    gameState.gameOver = true;
                    document.getElementById('finalScore').textContent = gameState.score;
                    document.getElementById('wavesSurvived').textContent = gameState.wave - 1;
                    document.getElementById('gameOver').style.display = 'flex';
                }

                updateUI();
            }

            // Draw
            drawBase();
            turrets.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = {
                isPlaying: true,
                score: 0,
                resources: 100,
                wave: 1,
                baseHealth: 100,
                gameOver: false,
                waveSpawning: false
            };
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            // Reset game speed
            gameSpeed = 1;
            document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
            document.getElementById('fastForwardBtn').classList.remove('active');
            
            // Clear any existing break timer
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
            }
            document.getElementById('waveBreak').style.display = 'none';
            
            initStars();
            document.getElementById('startScreen').style.display = 'none';
            spawnWave();
            updateUI();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);
        initStars();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

    <style>
        :root {
            --primary: #00ff88;
            --primary-dark: #00cc6a;
            --danger: #ff4444;
            --warning: #ffaa00;
            --bg-dark: #0a0a1a;
            --bg-panel: rgba(0, 20, 40, 0.85);
            --text: #ffffff;
            --glow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 2px solid var(--primary);
            border-radius: 10px;
            box-shadow: var(--glow), inset 0 0 50px rgba(0, 255, 136, 0.1);
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            border-radius: 8px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--bg-panel);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
        }

        .stat {
            margin: 8px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: #aaa;
            min-width: 90px;
        }

        .stat-value {
            color: var(--primary);
            font-weight: bold;
            font-size: 16px;
        }

        .stat-value.danger {
            color: var(--danger);
        }

        .stat-value.warning {
            color: var(--warning);
        }

        #costPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--bg-panel);
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        #costPanel.can-afford {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        #costPanel.cannot-afford {
            border-color: var(--danger);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }

        .cost-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .cost-value {
            font-size: 20px;
            font-weight: bold;
        }

        #turretSelect {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        .turret-option {
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .turret-option:hover {
            border-color: #888;
            transform: translateY(-2px);
        }

        .turret-option.selected {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .turret-option.cannot-afford {
            opacity: 0.5;
        }

        .turret-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
        }

        .turret-info {
            text-align: left;
        }

        .turret-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }

        .turret-cost {
            font-size: 10px;
            color: #aaa;
        }

        #controlPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        #controlPanel button {
            background: var(--bg-panel);
            color: var(--text);
            border: 2px solid #444;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #controlPanel button:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        #controlPanel button.active {
            border-color: var(--warning);
            background: rgba(255, 170, 0, 0.2);
        }

        #controlPanel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #nukeBtn {
            border-color: #ff4444;
        }

        #nukeBtn:hover:not(:disabled) {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff6666;
        }

        #freezeBtn {
            border-color: #44aaff;
        }

        #freezeBtn:hover:not(:disabled) {
            background: rgba(68, 170, 255, 0.2);
            border-color: #66ccff;
        }

        .boss-warning {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            color: #ff0066;
            text-shadow: 0 0 20px #ff0066;
            z-index: 55;
            animation: bossWarn 0.5s ease-in-out infinite;
        }

        @keyframes bossWarn {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .freeze-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(68, 170, 255, 0.2);
            pointer-events: none;
            z-index: 45;
            animation: freezeFade 3s ease-out forwards;
        }

        @keyframes freezeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .nuke-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 45;
            animation: nukeFade 0.5s ease-out forwards;
        }

        @keyframes nukeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #upgradePanel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            display: none;
            text-align: center;
        }

        #upgradePanel h3 {
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 14px;
        }

        #upgradePanel .stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 10px;
        }

        .upgrade-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #upgradePanel button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        #upgradePanel button:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        #upgradePanel button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen, #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #gameOver {
            display: none;
        }

        #startScreen h1, #gameOver h1 {
            font-size: 48px;
            color: var(--primary);
            margin-bottom: 10px;
            text-shadow: var(--glow);
            letter-spacing: 3px;
        }

        #startScreen p, #gameOver p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 16px;
        }

        #startScreen button, #gameOver button {
            font-size: 20px;
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
        }

        #startScreen button:hover, #gameOver button:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
            box-shadow: var(--glow);
        }

        #instructions {
            margin-top: 30px;
            max-width: 400px;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 12px 0;
            text-align: left;
            color: #ccc;
        }

        .instruction-item .icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }

        #finalScore, #wavesSurvived {
            color: var(--primary);
            font-size: 24px;
        }

        .popup-message {
            position: absolute;
            background: var(--bg-panel);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--primary);
            color: var(--text);
            font-size: 14px;
            pointer-events: none;
            animation: fadeUp 1.5s ease-out forwards;
            z-index: 50;
        }

        .popup-message.error {
            border-color: var(--danger);
            color: var(--danger);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .wave-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--primary);
            text-shadow: var(--glow);
            z-index: 50;
            animation: waveAnnounce 2s ease-out forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #waveBreak {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            padding: 25px 40px;
            border-radius: 15px;
            border: 2px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 60;
            text-align: center;
        }

        #waveBreak h2 {
            color: var(--primary);
            margin-bottom: 15px;
            text-shadow: var(--glow);
        }

        .break-timer {
            font-size: 18px;
            margin: 15px 0;
            color: #ccc;
        }

        .timer-num {
            font-size: 48px;
            font-weight: bold;
            color: var(--primary);
            display: block;
            margin: 10px 0;
            text-shadow: var(--glow);
        }

        .break-info {
            margin: 15px 0;
            color: #aaa;
        }

        .break-info .hint {
            color: var(--warning);
            font-weight: bold;
            margin-top: 8px;
        }

        #waveBreak button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            margin-top: 10px;
        }

        #waveBreak button:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div id="ui">
            <div class="stat">
                <span class="stat-label">Wave:</span>
                <span class="stat-value" id="wave">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Score:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Resources:</span>
                <span class="stat-value" id="resources">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Base Health:</span>
                <span class="stat-value" id="baseHealth">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Enemies:</span>
                <span class="stat-value" id="enemiesLeft">0</span>
            </div>
        </div>

        <div id="costPanel" class="can-afford">
            <div class="cost-label">SELECTED TURRET</div>
            <div class="cost-value" id="selectedTurretName">üíé 50</div>
        </div>

        <div id="turretSelect">
            <div class="turret-option selected" data-type="basic" onclick="selectTurretType('basic')">
                <div class="turret-icon" style="background: #00ff88;">B</div>
                <div class="turret-info">
                    <div class="turret-name">Basic</div>
                    <div class="turret-cost">50 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="rapid" onclick="selectTurretType('rapid')">
                <div class="turret-icon" style="background: #00ccff;">R</div>
                <div class="turret-info">
                    <div class="turret-name">Rapid</div>
                    <div class="turret-cost">75 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="cannon" onclick="selectTurretType('cannon')">
                <div class="turret-icon" style="background: #ff8800;">C</div>
                <div class="turret-info">
                    <div class="turret-name">Cannon</div>
                    <div class="turret-cost">100 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="slow" onclick="selectTurretType('slow')">
                <div class="turret-icon" style="background: #aa44ff;">S</div>
                <div class="turret-info">
                    <div class="turret-name">Slow</div>
                    <div class="turret-cost">60 üíé</div>
                </div>
            </div>
        </div>

        <div id="controlPanel">
            <button id="fastForwardBtn" onclick="toggleFastForward()">‚ñ∂‚ñ∂ 1x</button>
            <button id="nukeBtn" onclick="useNuke()">üí• Nuke (200üíé)</button>
            <button id="freezeBtn" onclick="useFreeze()">‚ùÑÔ∏è Freeze (100üíé)</button>
        </div>

        <div id="upgradePanel">
            <h3>‚öôÔ∏è TURRET OPTIONS</h3>
            <div class="stats" id="turretStats"></div>
            <div class="upgrade-buttons">
                <button id="upgradeBtn" onclick="upgradeTurret()">Upgrade (75 üíé)</button>
                <button id="sellBtn" onclick="sellTurret()" style="background: #ff4444;">Sell (+25 üíé)</button>
                <button onclick="closeUpgradePanel()" style="background: #444; color: #fff;">Close</button>
            </div>
        </div>

        <div id="waveBreak">
            <div class="break-content">
                <h2>‚ö° WAVE CLEARED!</h2>
                <div class="break-timer">
                    <span>Next wave in:</span>
                    <span id="breakTimer" class="timer-num">10</span>
                    <span>seconds</span>
                </div>
                <div class="break-info">
                    <p>Wave <span id="nextWaveNum">2</span> incoming: <span id="nextEnemyCount">9</span> enemies</p>
                    <p class="hint">Place turrets & upgrade now!</p>
                </div>
                <button onclick="skipBreak()">START NOW ‚Üí</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>SPACE DEFENSE COMMAND</h1>
            <p>Place turrets, defend your base, survive the alien invasion</p>
            <button onclick="startGame()">LAUNCH DEFENSE</button>
            <div id="instructions">
                <div class="instruction-item">
                    <div class="icon">üéØ</div>
                    <div>4 turret types: Basic, Rapid, Cannon, Slow</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üëæ</div>
                    <div>Enemy types: Normal, Scout (fast), Tank (tough), BOSS!</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üí•</div>
                    <div>Special abilities: Nuke (200üíé) & Freeze (100üíé)</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">‚ö†Ô∏è</div>
                    <div>Boss every 5 waves - prepare your defense!</div>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h1>DEFENSE BREACHED</h1>
            <p>Your base has fallen to the alien invasion</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="wavesSurvived">0</span></p>
            <button onclick="restartGame()">REDEPLOY DEFENSES</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            resources: 100,
            wave: 1,
            baseHealth: 100,
            gameOver: false,
            waveSpawning: false
        };

        // Game objects
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let stars = [];
        let selectedTurret = null;

        // Base position (right side)
        const base = {
            x: canvas.width - 60,
            y: canvas.height / 2,
            width: 80,
            height: 120
        };

        // Initialize starfield
        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random()
                });
            }
        }

        // Turret types configuration
        const turretTypes = {
            basic: {
                name: 'Basic',
                cost: 50,
                color: '#00ff88',
                colorDark: '#00cc6a',
                baseRange: 150,
                baseDamage: 25,
                baseFireRate: 800,
                description: 'Balanced turret'
            },
            rapid: {
                name: 'Rapid',
                cost: 75,
                color: '#00ccff',
                colorDark: '#0099cc',
                baseRange: 120,
                baseDamage: 10,
                baseFireRate: 250,
                description: 'Fast shots, low damage'
            },
            cannon: {
                name: 'Cannon',
                cost: 100,
                color: '#ff8800',
                colorDark: '#cc6600',
                baseRange: 180,
                baseDamage: 60,
                baseFireRate: 1500,
                splash: 40,
                description: 'Slow, high damage, splash'
            },
            slow: {
                name: 'Slow',
                cost: 60,
                color: '#aa44ff',
                colorDark: '#7722cc',
                baseRange: 130,
                baseDamage: 5,
                baseFireRate: 600,
                slowAmount: 0.5,
                slowDuration: 2000,
                description: 'Slows enemies down'
            }
        };

        let selectedTurretType = 'basic';

        // Turret class with upgrade system
        class Turret {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = turretTypes[type];
                this.level = 1;
                this.maxLevel = 3;
                this.baseRange = this.config.baseRange;
                this.baseDamage = this.config.baseDamage;
                this.baseFireRate = this.config.baseFireRate;
                this.splash = this.config.splash || 0;
                this.updateStats();
                this.lastShot = 0;
                this.target = null;
                this.angle = 0;
            }

            getSellValue() {
                // 50% of total invested (base cost + upgrade costs)
                let totalInvested = this.config.cost;
                for (let i = 1; i < this.level; i++) {
                    totalInvested += 50 + i * 25;
                }
                return Math.floor(totalInvested * 0.5);
            }

            updateStats() {
                this.range = this.baseRange + (this.level - 1) * 40;
                this.damage = this.baseDamage + (this.level - 1) * 15;
                this.fireRate = Math.max(300, this.baseFireRate - (this.level - 1) * 200);
            }

            getUpgradeCost() {
                return this.level < this.maxLevel ? 50 + this.level * 25 : null;
            }

            upgrade() {
                if (this.level < this.maxLevel) {
                    this.level++;
                    this.updateStats();
                    return true;
                }
                return false;
            }

            findTarget() {
                let closest = null;
                let closestDist = this.range;
                
                for (let enemy of enemies) {
                    let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = enemy;
                    }
                }
                this.target = closest;
            }

            update(currentTime) {
                this.findTarget();
                
                if (this.target) {
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    
                    // Adjust fire rate by game speed
                    let adjustedFireRate = this.fireRate / gameSpeed;
                    if (currentTime - this.lastShot > adjustedFireRate) {
                        projectiles.push(new Projectile(this.x, this.y, this.target, this.damage, this.level, this.type));
                        this.lastShot = currentTime;
                    }
                }
            }

            draw() {
                // Range indicator when selected
                if (selectedTurret === this) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.05)';
                    ctx.fill();
                }

                // Use turret type colors
                const color = {
                    main: this.config.color,
                    dark: this.config.colorDark
                };

                // Turret base
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 25);
                gradient.addColorStop(0, color.main);
                gradient.addColorStop(0.7, color.dark);
                gradient.addColorStop(1, '#004433');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 22 + this.level * 2, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.strokeStyle = color.main;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6 + this.level, 0, Math.PI * 2);
                ctx.fill();

                // Barrel - different style per type
                ctx.strokeStyle = color.main;
                ctx.lineWidth = this.type === 'cannon' ? 10 + this.level * 2 : 6 + this.level * 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * (28 + this.level * 4),
                    this.y + Math.sin(this.angle) * (28 + this.level * 4)
                );
                ctx.stroke();

                // Barrel highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Level indicator
                ctx.fillStyle = color.main;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚òÖ'.repeat(this.level), this.x, this.y + 35);
                
                // Type indicator
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = 'bold 8px sans-serif';
                ctx.fillText(this.config.name.toUpperCase(), this.x, this.y - 30);
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target, damage, level = 1, turretType = 'basic') {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.level = level;
                this.turretType = turretType;
                // Rapid is faster, cannon is slower
                if (turretType === 'rapid') {
                    this.speed = 8 + level;
                } else if (turretType === 'cannon') {
                    this.speed = 3 + level * 0.5;
                } else if (turretType === 'slow') {
                    this.speed = 6 + level;
                } else {
                    this.speed = 4 + level;
                }
                this.homing = 0.12;
                this.trail = [];
                this.splash = turretType === 'cannon' ? 40 + level * 10 : 0;
                
                // Slow effect properties
                if (turretType === 'slow') {
                    this.slowAmount = 0.5 - (level - 1) * 0.1; // Level 1: 50%, Level 2: 40%, Level 3: 30%
                    this.slowDuration = 2000 + (level - 1) * 500;
                }
            }

            update() {
                if (!this.target || !enemies.includes(this.target)) {
                    return false;
                }

                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) this.trail.shift();

                // Homing
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist < 15) {
                    this.target.health -= this.damage;
                    
                    // Apply slow effect
                    if (this.turretType === 'slow') {
                        this.target.applySlow(this.slowAmount, this.slowDuration);
                    }
                    
                    // Splash damage for cannon
                    if (this.splash > 0) {
                        for (let enemy of enemies) {
                            if (enemy !== this.target) {
                                let splashDist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                if (splashDist < this.splash) {
                                    enemy.health -= this.damage * 0.5;
                                }
                            }
                        }
                        createExplosion(this.x, this.y, 3);
                    } else {
                        createExplosion(this.x, this.y, this.level);
                    }
                    return false;
                }

                this.x += (dx / dist) * this.speed * gameSpeed;
                this.y += (dy / dist) * this.speed * gameSpeed;
                return true;
            }

            draw() {
                // Trail
                const trailColors = {
                    basic: '#00ff88',
                    rapid: '#00ccff', 
                    cannon: '#ff8800',
                    slow: '#aa44ff'
                };
                
                for (let i = 0; i < this.trail.length; i++) {
                    let alpha = i / this.trail.length * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = trailColors[this.turretType];
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, this.turretType === 'cannon' ? 4 : 2 + this.level, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Main projectile
                ctx.fillStyle = trailColors[this.turretType];
                ctx.shadowColor = trailColors[this.turretType];
                ctx.shadowBlur = 10;
                ctx.beginPath();
                let size = this.turretType === 'cannon' ? 6 + this.level : 4 + this.level;
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Enemy types configuration
        const enemyTypes = {
            scout: {
                name: 'Scout',
                color: '#ffff00',
                colorDark: '#cccc00',
                speedMult: 2.0,
                healthMult: 0.4,
                sizeMult: 0.7,
                valueMult: 0.8
            },
            normal: {
                name: 'Normal',
                color: '#ff6666',
                colorDark: '#cc3333',
                speedMult: 1.0,
                healthMult: 1.0,
                sizeMult: 1.0,
                valueMult: 1.0
            },
            tank: {
                name: 'Tank',
                color: '#aa44ff',
                colorDark: '#7722cc',
                speedMult: 0.5,
                healthMult: 2.5,
                sizeMult: 1.4,
                valueMult: 2.0
            },
            boss: {
                name: 'BOSS',
                color: '#ff0066',
                colorDark: '#cc0044',
                speedMult: 0.3,
                healthMult: 10.0,
                sizeMult: 2.0,
                valueMult: 10.0
            }
        };

        // Game speed multiplier
        let gameSpeed = 1;

        // Single lane for enemy path
        const lane = 350;  // Center of screen

        // Enemy class
        class Enemy {
            constructor(wave, type = 'normal') {
                this.x = -30;
                this.y = lane;
                this.type = type;
                this.config = enemyTypes[type];
                
                // Base stats modified by type
                let baseSpeed = 0.4 + wave * 0.08;
                let baseHealth = 40 + wave * 15;
                let baseSize = 18 + Math.min(wave, 10);
                let baseValue = 10 + wave * 3;
                
                this.baseSpeed = baseSpeed * this.config.speedMult;
                this.speed = this.baseSpeed + Math.random() * 0.1;
                this.maxHealth = Math.floor(baseHealth * this.config.healthMult);
                this.health = this.maxHealth;
                this.size = Math.floor(baseSize * this.config.sizeMult);
                this.value = Math.floor(baseValue * this.config.valueMult);
                
                // Slow effect
                this.slowedUntil = 0;
                this.slowAmount = 1;
            }

            applySlow(amount, duration) {
                this.slowAmount = amount;
                this.slowedUntil = Date.now() + duration;
            }

            update() {
                // Check if slow expired
                if (Date.now() > this.slowedUntil) {
                    this.slowAmount = 1;
                }
                
                // Apply speed with slow effect and game speed
                let currentSpeed = this.speed * this.slowAmount * gameSpeed;
                
                // Straight horizontal path toward base - strict lane movement
                this.x += currentSpeed;
                // Keep Y position locked to lane
                this.y = lane;

                // Check if reached base
                if (this.x > base.x - 40) {
                    gameState.baseHealth -= 10;
                    updateUI();
                    return false;
                }

                // Check if dead
                if (this.health <= 0) {
                    gameState.score += this.value;
                    gameState.resources += Math.floor(this.value / 2);
                    createExplosion(this.x, this.y, 2);
                    updateUI();
                    return false;
                }

                return true;
            }

            draw() {
                // Slow effect indicator
                if (this.slowAmount < 1) {
                    ctx.strokeStyle = 'rgba(170, 68, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enemy body - use type colors
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.config.color);
                gradient.addColorStop(0.5, this.config.colorDark);
                gradient.addColorStop(1, '#220000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Spikes - different count per type
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = this.type === 'tank' || this.type === 'boss' ? 4 : 3;
                let spikeCount = this.type === 'scout' ? 4 : this.type === 'boss' ? 12 : this.type === 'tank' ? 8 : 6;
                for (let i = 0; i < spikeCount; i++) {
                    let angle = (i / spikeCount) * Math.PI * 2 + Date.now() / 1000;
                    let spikeLength = this.type === 'boss' ? 15 : 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * this.size, this.y + Math.sin(angle) * this.size);
                    ctx.lineTo(this.x + Math.cos(angle) * (this.size + spikeLength), this.y + Math.sin(angle) * (this.size + spikeLength));
                    ctx.stroke();
                }

                // Health bar
                let healthPercent = this.health / this.maxHealth;
                let barWidth = this.size * 2;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth, 6);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffaa00' : '#ff4444';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth * healthPercent, 6);
                
                // Type label for tanks and bosses
                if (this.type === 'tank' || this.type === 'boss') {
                    ctx.fillStyle = this.type === 'boss' ? '#ff0066' : 'rgba(255,255,255,0.7)';
                    ctx.font = this.type === 'boss' ? 'bold 12px sans-serif' : 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.type.toUpperCase(), this.x, this.y - this.size - 16);
                }
                
                // Boss glow effect
                if (this.type === 'boss') {
                    ctx.strokeStyle = `rgba(255, 0, 102, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx * gameSpeed;
                this.y += this.vy * gameSpeed;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life -= gameSpeed;
                return this.life > 0;
            }

            draw() {
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createExplosion(x, y, intensity = 1) {
            const colors = ['rgb(255, 136, 0)', 'rgb(255, 200, 0)', 'rgb(255, 68, 68)', 'rgb(255, 255, 255)'];
            for (let i = 0; i < 8 * intensity; i++) {
                particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function spawnWave() {
            // Wave 1 = 4 enemies, then +5 per wave (wave 2 = 9, wave 3 = 14, etc.)
            let enemyCount = 4 + (gameState.wave - 1) * 5;
            gameState.waveSpawning = true;
            
            // Boss wave every 5 waves
            let isBossWave = gameState.wave % 5 === 0;
            
            for (let i = 0; i < enemyCount; i++) {
                // Determine enemy type based on wave and randomness
                let type = 'normal';
                let roll = Math.random();
                
                // Scouts appear from wave 2+
                if (gameState.wave >= 2 && roll < 0.3) {
                    type = 'scout';
                }
                // Tanks appear from wave 3+
                else if (gameState.wave >= 3 && roll > 0.85) {
                    type = 'tank';
                }
                
                // Slower spawn rate - more time between enemies
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, type));
                    }
                    // Mark spawning complete after last enemy
                    if (i === enemyCount - 1) {
                        gameState.waveSpawning = false;
                    }
                }, i * (1200 - Math.min(gameState.wave * 40, 600)));
            }
            
            // Spawn boss at the end of boss waves
            if (isBossWave) {
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, 'boss'));
                        showBossWarning();
                    }
                }, enemyCount * (1200 - Math.min(gameState.wave * 40, 600)) + 1000);
            }
            
            showWaveAnnouncement(isBossWave);
        }
        
        function showBossWarning() {
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.textContent = '‚ö†Ô∏è BOSS INCOMING! ‚ö†Ô∏è';
            document.getElementById('gameContainer').appendChild(warning);
            setTimeout(() => warning.remove(), 2000);
        }

        let waveBreakTimer = null;
        let breakTimeLeft = 0;

        function startWaveBreak() {
            breakTimeLeft = 10;
            updateBreakDisplay();
            document.getElementById('waveBreak').style.display = 'flex';
            
            waveBreakTimer = setInterval(() => {
                breakTimeLeft--;
                updateBreakDisplay();
                
                if (breakTimeLeft <= 0) {
                    clearInterval(waveBreakTimer);
                    document.getElementById('waveBreak').style.display = 'none';
                    gameState.wave++;
                    spawnWave();
                }
            }, 1000);
        }

        function updateBreakDisplay() {
            document.getElementById('breakTimer').textContent = breakTimeLeft;
            document.getElementById('nextWaveNum').textContent = gameState.wave + 1;
            // Show how many enemies next wave
            let nextEnemyCount = 4 + gameState.wave * 5;
            document.getElementById('nextEnemyCount').textContent = nextEnemyCount;
        }

        function skipBreak() {
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
                document.getElementById('waveBreak').style.display = 'none';
                gameState.wave++;
                spawnWave();
            }
        }

        function showWaveAnnouncement(isBossWave = false) {
            const announcement = document.createElement('div');
            announcement.className = 'wave-announcement';
            if (isBossWave) {
                announcement.innerHTML = `WAVE ${gameState.wave}<br><span style="color: #ff0066; font-size: 24px;">‚ö†Ô∏è BOSS WAVE ‚ö†Ô∏è</span>`;
            } else {
                announcement.textContent = `WAVE ${gameState.wave}`;
            }
            document.getElementById('gameContainer').appendChild(announcement);
            setTimeout(() => announcement.remove(), 2000);
        }

        function showPopup(x, y, message, isError = false) {
            const popup = document.createElement('div');
            popup.className = 'popup-message' + (isError ? ' error' : '');
            popup.textContent = message;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        function handleClick(e) {
            if (!gameState.isPlaying || gameState.gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicked on existing turret
            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 30) {
                    selectedTurret = turret;
                    showUpgradePanel(turret);
                    return;
                }
            }

            // Close upgrade panel if clicking elsewhere
            closeUpgradePanel();

            // Check placement validity
            if (x > canvas.width - 150) {
                showPopup(x, y - 20, "Too close to base!", true);
                return;
            }

            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 60) {
                    showPopup(x, y - 20, "Too close to turret!", true);
                    return;
                }
            }

            if (gameState.resources >= turretTypes[selectedTurretType].cost) {
                turrets.push(new Turret(x, y, selectedTurretType));
                gameState.resources -= turretTypes[selectedTurretType].cost;
                showPopup(x, y - 20, `${turretTypes[selectedTurretType].name} deployed!`);
                updateUI();
            } else {
                showPopup(x, y - 20, `Need ${turretTypes[selectedTurretType].cost} resources!`, true);
            }
        }

        function selectTurretType(type) {
            selectedTurretType = type;
            // Update UI
            document.querySelectorAll('.turret-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.type === type) {
                    opt.classList.add('selected');
                }
            });
            updateUI();
        }

        function showUpgradePanel(turret) {
            const panel = document.getElementById('upgradePanel');
            const stats = document.getElementById('turretStats');
            const btn = document.getElementById('upgradeBtn');
            const sellBtn = document.getElementById('sellBtn');
            
            stats.innerHTML = `${turret.config.name} Lv${turret.level}/${turret.maxLevel} | DMG: ${turret.damage} | Range: ${turret.range}`;
            
            const cost = turret.getUpgradeCost();
            if (cost) {
                btn.textContent = `Upgrade (${cost} üíé)`;
                btn.disabled = gameState.resources < cost;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
            
            // Sell button
            const sellValue = turret.getSellValue();
            sellBtn.textContent = `Sell (+${sellValue} üíé)`;
            
            panel.style.display = 'flex';
        }

        function sellTurret() {
            if (!selectedTurret) return;
            
            const sellValue = selectedTurret.getSellValue();
            gameState.resources += sellValue;
            
            // Remove turret from array
            const index = turrets.indexOf(selectedTurret);
            if (index > -1) {
                turrets.splice(index, 1);
            }
            
            showPopup(selectedTurret.x, selectedTurret.y - 30, `Sold for ${sellValue} üíé`);
            closeUpgradePanel();
            updateUI();
        }

        function toggleFastForward() {
            if (gameSpeed === 1) {
                gameSpeed = 2;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 2x';
                document.getElementById('fastForwardBtn').classList.add('active');
            } else {
                gameSpeed = 1;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
                document.getElementById('fastForwardBtn').classList.remove('active');
            }
        }

        function useNuke() {
            if (gameState.resources < 200 || enemies.length === 0) return;
            
            gameState.resources -= 200;
            
            // Damage all enemies
            for (let enemy of enemies) {
                enemy.health -= 100;
                createExplosion(enemy.x, enemy.y, 2);
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'nuke-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 500);
            
            showPopup(canvas.width / 2, canvas.height / 2, 'üí• NUKE ACTIVATED!');
            updateUI();
        }

        function useFreeze() {
            if (gameState.resources < 100 || enemies.length === 0) return;
            
            gameState.resources -= 100;
            
            // Freeze all enemies for 3 seconds
            for (let enemy of enemies) {
                enemy.applySlow(0, 3000); // 0 = completely stopped
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'freeze-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 3000);
            
            showPopup(canvas.width / 2, canvas.height / 2, '‚ùÑÔ∏è FREEZE ACTIVATED!');
            updateUI();
        }

        function closeUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            selectedTurret = null;
        }

        function upgradeTurret() {
            if (!selectedTurret) return;
            
            const cost = selectedTurret.getUpgradeCost();
            if (cost && gameState.resources >= cost) {
                gameState.resources -= cost;
                selectedTurret.upgrade();
                showPopup(selectedTurret.x, selectedTurret.y - 30, `Upgraded to Level ${selectedTurret.level}!`);
                showUpgradePanel(selectedTurret);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('resources').textContent = gameState.resources;
            document.getElementById('baseHealth').textContent = gameState.baseHealth;
            document.getElementById('enemiesLeft').textContent = enemies.length;

            // Health color
            const healthEl = document.getElementById('baseHealth');
            healthEl.className = 'stat-value';
            if (gameState.baseHealth <= 25) healthEl.classList.add('danger');
            else if (gameState.baseHealth <= 50) healthEl.classList.add('warning');

            // Cost panel - show selected turret
            const costPanel = document.getElementById('costPanel');
            const selectedConfig = turretTypes[selectedTurretType];
            document.getElementById('selectedTurretName').textContent = `${selectedConfig.name} - ${selectedConfig.cost} üíé`;
            costPanel.className = gameState.resources >= selectedConfig.cost ? 'can-afford' : 'cannot-afford';
            
            // Update turret selection buttons affordability
            document.querySelectorAll('.turret-option').forEach(opt => {
                const type = opt.dataset.type;
                const cost = turretTypes[type].cost;
                if (gameState.resources < cost) {
                    opt.classList.add('cannot-afford');
                } else {
                    opt.classList.remove('cannot-afford');
                }
            });
            
            // Update ability buttons
            document.getElementById('nukeBtn').disabled = gameState.resources < 200;
            document.getElementById('freezeBtn').disabled = gameState.resources < 100;
        }

        function drawStars() {
            for (let star of stars) {
                star.x -= star.speed;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
                
                let twinkle = 0.5 + Math.sin(Date.now() / 500 + star.brightness * 10) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLanes() {
            // Draw single lane path so player knows where enemies will travel
            let y = lane;
            
            // Lane background stripe
            ctx.fillStyle = 'rgba(255, 100, 100, 0.08)';
            ctx.fillRect(0, y - 30, canvas.width - 100, 60);
            
            // Lane guide line (dashed)
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.25)';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width - 100, y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Lane edges
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y - 30);
            ctx.lineTo(canvas.width - 100, y - 30);
            ctx.moveTo(0, y + 30);
            ctx.lineTo(canvas.width - 100, y + 30);
            ctx.stroke();
        }

        function drawBase() {
            // Base glow
            const glow = ctx.createRadialGradient(base.x, base.y, 0, base.x, base.y, 80);
            glow.addColorStop(0, 'rgba(0, 136, 255, 0.3)');
            glow.addColorStop(1, 'rgba(0, 136, 255, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 80, 0, Math.PI * 2);
            ctx.fill();

            // Base structure
            const gradient = ctx.createLinearGradient(base.x - 40, 0, base.x + 40, 0);
            gradient.addColorStop(0, '#0066aa');
            gradient.addColorStop(0.5, '#0088ff');
            gradient.addColorStop(1, '#0066aa');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(base.x - 30, base.y + 50);
            ctx.lineTo(base.x - 40, base.y);
            ctx.lineTo(base.x - 30, base.y - 50);
            ctx.lineTo(base.x + 20, base.y - 40);
            ctx.lineTo(base.x + 30, base.y);
            ctx.lineTo(base.x + 20, base.y + 40);
            ctx.closePath();
            ctx.fill();

            // Shield effect
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.3 + Math.sin(Date.now() / 300) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 55, 0, Math.PI * 2);
            ctx.stroke();

            // Health indicator
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', base.x, base.y + 70);
        }

        function gameLoop(timestamp) {
            // Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Background
            drawStars();
            drawLanes();

            if (gameState.isPlaying && !gameState.gameOver) {
                // Update
                turrets.forEach(t => t.update(timestamp));
                projectiles = projectiles.filter(p => p.update());
                enemies = enemies.filter(e => e.update());
                particles = particles.filter(p => p.update());

                // Check wave complete - start break timer instead of immediate spawn
                if (enemies.length === 0 && gameState.isPlaying && !gameState.waveSpawning && document.getElementById('waveBreak').style.display !== 'flex') {
                    startWaveBreak();
                }

                // Check game over
                if (gameState.baseHealth <= 0) {
                    gameState.gameOver = true;
                    document.getElementById('finalScore').textContent = gameState.score;
                    document.getElementById('wavesSurvived').textContent = gameState.wave - 1;
                    document.getElementById('gameOver').style.display = 'flex';
                }

                updateUI();
            }

            // Draw
            drawBase();
            turrets.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = {
                isPlaying: true,
                score: 0,
                resources: 100,
                wave: 1,
                baseHealth: 100,
                gameOver: false,
                waveSpawning: false
            };
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            // Reset game speed
            gameSpeed = 1;
            document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
            document.getElementById('fastForwardBtn').classList.remove('active');
            
            // Clear any existing break timer
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
            }
            document.getElementById('waveBreak').style.display = 'none';
            
            initStars();
            document.getElementById('startScreen').style.display = 'none';
            spawnWave();
            updateUI();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);
        initStars();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

    <style><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense Command</title>
    <style>
        :root {
            --primary: #00ff88;
            --primary-dark: #00cc6a;
            --danger: #ff4444;
            --warning: #ffaa00;
            --bg-dark: #0a0a1a;
            --bg-panel: rgba(0, 20, 40, 0.85);
            --text: #ffffff;
            --glow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 2px solid var(--primary);
            border-radius: 10px;
            box-shadow: var(--glow), inset 0 0 50px rgba(0, 255, 136, 0.1);
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            border-radius: 8px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--bg-panel);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
        }

        .stat {
            margin: 8px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: #aaa;
            min-width: 90px;
        }

        .stat-value {
            color: var(--primary);
            font-weight: bold;
            font-size: 16px;
        }

        .stat-value.danger {
            color: var(--danger);
        }

        .stat-value.warning {
            color: var(--warning);
        }

        #costPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--bg-panel);
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        #costPanel.can-afford {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        #costPanel.cannot-afford {
            border-color: var(--danger);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }

        .cost-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .cost-value {
            font-size: 20px;
            font-weight: bold;
        }

        #turretSelect {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        .turret-option {
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .turret-option:hover {
            border-color: #888;
            transform: translateY(-2px);
        }

        .turret-option.selected {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .turret-option.cannot-afford {
            opacity: 0.5;
        }

        .turret-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
        }

        .turret-info {
            text-align: left;
        }

        .turret-name {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }

        .turret-cost {
            font-size: 10px;
            color: #aaa;
        }

        #controlPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 40;
        }

        #controlPanel button {
            background: var(--bg-panel);
            color: var(--text);
            border: 2px solid #444;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #controlPanel button:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        #controlPanel button.active {
            border-color: var(--warning);
            background: rgba(255, 170, 0, 0.2);
        }

        #controlPanel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #nukeBtn {
            border-color: #ff4444;
        }

        #nukeBtn:hover:not(:disabled) {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff6666;
        }

        #freezeBtn {
            border-color: #44aaff;
        }

        #freezeBtn:hover:not(:disabled) {
            background: rgba(68, 170, 255, 0.2);
            border-color: #66ccff;
        }

        .boss-warning {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            color: #ff0066;
            text-shadow: 0 0 20px #ff0066;
            z-index: 55;
            animation: bossWarn 0.5s ease-in-out infinite;
        }

        @keyframes bossWarn {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .freeze-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(68, 170, 255, 0.2);
            pointer-events: none;
            z-index: 45;
            animation: freezeFade 3s ease-out forwards;
        }

        @keyframes freezeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .nuke-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 45;
            animation: nukeFade 0.5s ease-out forwards;
        }

        @keyframes nukeFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        #upgradePanel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary);
            backdrop-filter: blur(10px);
            display: none;
            text-align: center;
        }

        #upgradePanel h3 {
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 14px;
        }

        #upgradePanel .stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 10px;
        }

        .upgrade-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #upgradePanel button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        #upgradePanel button:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        #upgradePanel button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen, #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #gameOver {
            display: none;
        }

        #startScreen h1, #gameOver h1 {
            font-size: 48px;
            color: var(--primary);
            margin-bottom: 10px;
            text-shadow: var(--glow);
            letter-spacing: 3px;
        }

        #startScreen p, #gameOver p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 16px;
        }

        #startScreen button, #gameOver button {
            font-size: 20px;
            padding: 15px 40px;
            background: var(--primary);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
        }

        #startScreen button:hover, #gameOver button:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
            box-shadow: var(--glow);
        }

        #instructions {
            margin-top: 30px;
            max-width: 400px;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 12px 0;
            text-align: left;
            color: #ccc;
        }

        .instruction-item .icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }

        #finalScore, #wavesSurvived {
            color: var(--primary);
            font-size: 24px;
        }

        .popup-message {
            position: absolute;
            background: var(--bg-panel);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--primary);
            color: var(--text);
            font-size: 14px;
            pointer-events: none;
            animation: fadeUp 1.5s ease-out forwards;
            z-index: 50;
        }

        .popup-message.error {
            border-color: var(--danger);
            color: var(--danger);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .wave-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--primary);
            text-shadow: var(--glow);
            z-index: 50;
            animation: waveAnnounce 2s ease-out forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #waveBreak {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            padding: 25px 40px;
            border-radius: 15px;
            border: 2px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--glow);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 60;
            text-align: center;
        }

        #waveBreak h2 {
            color: var(--primary);
            margin-bottom: 15px;
            text-shadow: var(--glow);
        }

        .break-timer {
            font-size: 18px;
            margin: 15px 0;
            color: #ccc;
        }

        .timer-num {
            font-size: 48px;
            font-weight: bold;
            color: var(--primary);
            display: block;
            margin: 10px 0;
            text-shadow: var(--glow);
        }

        .break-info {
            margin: 15px 0;
            color: #aaa;
        }

        .break-info .hint {
            color: var(--warning);
            font-weight: bold;
            margin-top: 8px;
        }

        #waveBreak button {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
            margin-top: 10px;
        }

        #waveBreak button:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div id="ui">
            <div class="stat">
                <span class="stat-label">Wave:</span>
                <span class="stat-value" id="wave">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Score:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Resources:</span>
                <span class="stat-value" id="resources">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Base Health:</span>
                <span class="stat-value" id="baseHealth">100</span>
            </div>
            <div class="stat">
                <span class="stat-label">Enemies:</span>
                <span class="stat-value" id="enemiesLeft">0</span>
            </div>
        </div>

        <div id="costPanel" class="can-afford">
            <div class="cost-label">SELECTED TURRET</div>
            <div class="cost-value" id="selectedTurretName">üíé 50</div>
        </div>

        <div id="turretSelect">
            <div class="turret-option selected" data-type="basic" onclick="selectTurretType('basic')">
                <div class="turret-icon" style="background: #00ff88;">B</div>
                <div class="turret-info">
                    <div class="turret-name">Basic</div>
                    <div class="turret-cost">50 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="rapid" onclick="selectTurretType('rapid')">
                <div class="turret-icon" style="background: #00ccff;">R</div>
                <div class="turret-info">
                    <div class="turret-name">Rapid</div>
                    <div class="turret-cost">75 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="cannon" onclick="selectTurretType('cannon')">
                <div class="turret-icon" style="background: #ff8800;">C</div>
                <div class="turret-info">
                    <div class="turret-name">Cannon</div>
                    <div class="turret-cost">100 üíé</div>
                </div>
            </div>
            <div class="turret-option" data-type="slow" onclick="selectTurretType('slow')">
                <div class="turret-icon" style="background: #aa44ff;">S</div>
                <div class="turret-info">
                    <div class="turret-name">Slow</div>
                    <div class="turret-cost">60 üíé</div>
                </div>
            </div>
        </div>

        <div id="controlPanel">
            <button id="fastForwardBtn" onclick="toggleFastForward()">‚ñ∂‚ñ∂ 1x</button>
            <button id="nukeBtn" onclick="useNuke()">üí• Nuke (200üíé)</button>
            <button id="freezeBtn" onclick="useFreeze()">‚ùÑÔ∏è Freeze (100üíé)</button>
        </div>

        <div id="upgradePanel">
            <h3>‚öôÔ∏è TURRET OPTIONS</h3>
            <div class="stats" id="turretStats"></div>
            <div class="upgrade-buttons">
                <button id="upgradeBtn" onclick="upgradeTurret()">Upgrade (75 üíé)</button>
                <button id="sellBtn" onclick="sellTurret()" style="background: #ff4444;">Sell (+25 üíé)</button>
                <button onclick="closeUpgradePanel()" style="background: #444; color: #fff;">Close</button>
            </div>
        </div>

        <div id="waveBreak">
            <div class="break-content">
                <h2>‚ö° WAVE CLEARED!</h2>
                <div class="break-timer">
                    <span>Next wave in:</span>
                    <span id="breakTimer" class="timer-num">10</span>
                    <span>seconds</span>
                </div>
                <div class="break-info">
                    <p>Wave <span id="nextWaveNum">2</span> incoming: <span id="nextEnemyCount">9</span> enemies</p>
                    <p class="hint">Place turrets & upgrade now!</p>
                </div>
                <button onclick="skipBreak()">START NOW ‚Üí</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>SPACE DEFENSE COMMAND</h1>
            <p>Place turrets, defend your base, survive the alien invasion</p>
            <button onclick="startGame()">LAUNCH DEFENSE</button>
            <div id="instructions">
                <div class="instruction-item">
                    <div class="icon">üéØ</div>
                    <div>4 turret types: Basic, Rapid, Cannon, Slow</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üëæ</div>
                    <div>Enemy types: Normal, Scout (fast), Tank (tough), BOSS!</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">üí•</div>
                    <div>Special abilities: Nuke (200üíé) & Freeze (100üíé)</div>
                </div>
                <div class="instruction-item">
                    <div class="icon">‚ö†Ô∏è</div>
                    <div>Boss every 5 waves - prepare your defense!</div>
                </div>
            </div>
        </div>

        <div id="gameOver">
            <h1>DEFENSE BREACHED</h1>
            <p>Your base has fallen to the alien invasion</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="wavesSurvived">0</span></p>
            <button onclick="restartGame()">REDEPLOY DEFENSES</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            resources: 100,
            wave: 1,
            baseHealth: 100,
            gameOver: false,
            waveSpawning: false
        };

        // Game objects
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let stars = [];
        let selectedTurret = null;

        // Base position (right side)
        const base = {
            x: canvas.width - 60,
            y: canvas.height / 2,
            width: 80,
            height: 120
        };

        // Initialize starfield
        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random()
                });
            }
        }

        // Turret types configuration
        const turretTypes = {
            basic: {
                name: 'Basic',
                cost: 50,
                color: '#00ff88',
                colorDark: '#00cc6a',
                baseRange: 150,
                baseDamage: 25,
                baseFireRate: 800,
                description: 'Balanced turret'
            },
            rapid: {
                name: 'Rapid',
                cost: 75,
                color: '#00ccff',
                colorDark: '#0099cc',
                baseRange: 120,
                baseDamage: 10,
                baseFireRate: 250,
                description: 'Fast shots, low damage'
            },
            cannon: {
                name: 'Cannon',
                cost: 100,
                color: '#ff8800',
                colorDark: '#cc6600',
                baseRange: 180,
                baseDamage: 60,
                baseFireRate: 1500,
                splash: 40,
                description: 'Slow, high damage, splash'
            },
            slow: {
                name: 'Slow',
                cost: 60,
                color: '#aa44ff',
                colorDark: '#7722cc',
                baseRange: 130,
                baseDamage: 5,
                baseFireRate: 600,
                slowAmount: 0.5,
                slowDuration: 2000,
                description: 'Slows enemies down'
            }
        };

        let selectedTurretType = 'basic';

        // Turret class with upgrade system
        class Turret {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = turretTypes[type];
                this.level = 1;
                this.maxLevel = 3;
                this.baseRange = this.config.baseRange;
                this.baseDamage = this.config.baseDamage;
                this.baseFireRate = this.config.baseFireRate;
                this.splash = this.config.splash || 0;
                this.updateStats();
                this.lastShot = 0;
                this.target = null;
                this.angle = 0;
            }

            getSellValue() {
                // 50% of total invested (base cost + upgrade costs)
                let totalInvested = this.config.cost;
                for (let i = 1; i < this.level; i++) {
                    totalInvested += 50 + i * 25;
                }
                return Math.floor(totalInvested * 0.5);
            }

            updateStats() {
                this.range = this.baseRange + (this.level - 1) * 40;
                this.damage = this.baseDamage + (this.level - 1) * 15;
                this.fireRate = Math.max(300, this.baseFireRate - (this.level - 1) * 200);
            }

            getUpgradeCost() {
                return this.level < this.maxLevel ? 50 + this.level * 25 : null;
            }

            upgrade() {
                if (this.level < this.maxLevel) {
                    this.level++;
                    this.updateStats();
                    return true;
                }
                return false;
            }

            findTarget() {
                let closest = null;
                let closestDist = this.range;
                
                for (let enemy of enemies) {
                    let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = enemy;
                    }
                }
                this.target = closest;
            }

            update(currentTime) {
                this.findTarget();
                
                if (this.target) {
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    
                    // Adjust fire rate by game speed
                    let adjustedFireRate = this.fireRate / gameSpeed;
                    if (currentTime - this.lastShot > adjustedFireRate) {
                        projectiles.push(new Projectile(this.x, this.y, this.target, this.damage, this.level, this.type));
                        this.lastShot = currentTime;
                    }
                }
            }

            draw() {
                // Range indicator when selected
                if (selectedTurret === this) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.05)';
                    ctx.fill();
                }

                // Use turret type colors
                const color = {
                    main: this.config.color,
                    dark: this.config.colorDark
                };

                // Turret base
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 25);
                gradient.addColorStop(0, color.main);
                gradient.addColorStop(0.7, color.dark);
                gradient.addColorStop(1, '#004433');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 22 + this.level * 2, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.strokeStyle = color.main;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6 + this.level, 0, Math.PI * 2);
                ctx.fill();

                // Barrel - different style per type
                ctx.strokeStyle = color.main;
                ctx.lineWidth = this.type === 'cannon' ? 10 + this.level * 2 : 6 + this.level * 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * (28 + this.level * 4),
                    this.y + Math.sin(this.angle) * (28 + this.level * 4)
                );
                ctx.stroke();

                // Barrel highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Level indicator
                ctx.fillStyle = color.main;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚òÖ'.repeat(this.level), this.x, this.y + 35);
                
                // Type indicator
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = 'bold 8px sans-serif';
                ctx.fillText(this.config.name.toUpperCase(), this.x, this.y - 30);
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target, damage, level = 1, turretType = 'basic') {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.level = level;
                this.turretType = turretType;
                // Rapid is faster, cannon is slower
                if (turretType === 'rapid') {
                    this.speed = 8 + level;
                } else if (turretType === 'cannon') {
                    this.speed = 3 + level * 0.5;
                } else if (turretType === 'slow') {
                    this.speed = 6 + level;
                } else {
                    this.speed = 4 + level;
                }
                this.homing = 0.12;
                this.trail = [];
                this.splash = turretType === 'cannon' ? 40 + level * 10 : 0;
                
                // Slow effect properties
                if (turretType === 'slow') {
                    this.slowAmount = 0.5 - (level - 1) * 0.1; // Level 1: 50%, Level 2: 40%, Level 3: 30%
                    this.slowDuration = 2000 + (level - 1) * 500;
                }
            }

            update() {
                if (!this.target || !enemies.includes(this.target)) {
                    return false;
                }

                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) this.trail.shift();

                // Homing
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist < 15) {
                    this.target.health -= this.damage;
                    
                    // Apply slow effect
                    if (this.turretType === 'slow') {
                        this.target.applySlow(this.slowAmount, this.slowDuration);
                    }
                    
                    // Splash damage for cannon
                    if (this.splash > 0) {
                        for (let enemy of enemies) {
                            if (enemy !== this.target) {
                                let splashDist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                if (splashDist < this.splash) {
                                    enemy.health -= this.damage * 0.5;
                                }
                            }
                        }
                        createExplosion(this.x, this.y, 3);
                    } else {
                        createExplosion(this.x, this.y, this.level);
                    }
                    return false;
                }

                this.x += (dx / dist) * this.speed * gameSpeed;
                this.y += (dy / dist) * this.speed * gameSpeed;
                return true;
            }

            draw() {
                // Trail
                const trailColors = {
                    basic: '#00ff88',
                    rapid: '#00ccff', 
                    cannon: '#ff8800',
                    slow: '#aa44ff'
                };
                
                for (let i = 0; i < this.trail.length; i++) {
                    let alpha = i / this.trail.length * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = trailColors[this.turretType];
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, this.turretType === 'cannon' ? 4 : 2 + this.level, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Main projectile
                ctx.fillStyle = trailColors[this.turretType];
                ctx.shadowColor = trailColors[this.turretType];
                ctx.shadowBlur = 10;
                ctx.beginPath();
                let size = this.turretType === 'cannon' ? 6 + this.level : 4 + this.level;
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Enemy types configuration
        const enemyTypes = {
            scout: {
                name: 'Scout',
                color: '#ffff00',
                colorDark: '#cccc00',
                speedMult: 2.0,
                healthMult: 0.4,
                sizeMult: 0.7,
                valueMult: 0.8
            },
            normal: {
                name: 'Normal',
                color: '#ff6666',
                colorDark: '#cc3333',
                speedMult: 1.0,
                healthMult: 1.0,
                sizeMult: 1.0,
                valueMult: 1.0
            },
            tank: {
                name: 'Tank',
                color: '#aa44ff',
                colorDark: '#7722cc',
                speedMult: 0.5,
                healthMult: 2.5,
                sizeMult: 1.4,
                valueMult: 2.0
            },
            boss: {
                name: 'BOSS',
                color: '#ff0066',
                colorDark: '#cc0044',
                speedMult: 0.3,
                healthMult: 10.0,
                sizeMult: 2.0,
                valueMult: 10.0
            }
        };

        // Game speed multiplier
        let gameSpeed = 1;

        // Single lane for enemy path
        const lane = 350;  // Center of screen

        // Enemy class
        class Enemy {
            constructor(wave, type = 'normal') {
                this.x = -30;
                this.y = lane;
                this.type = type;
                this.config = enemyTypes[type];
                
                // Base stats modified by type
                let baseSpeed = 0.4 + wave * 0.08;
                let baseHealth = 40 + wave * 15;
                let baseSize = 18 + Math.min(wave, 10);
                let baseValue = 10 + wave * 3;
                
                this.baseSpeed = baseSpeed * this.config.speedMult;
                this.speed = this.baseSpeed + Math.random() * 0.1;
                this.maxHealth = Math.floor(baseHealth * this.config.healthMult);
                this.health = this.maxHealth;
                this.size = Math.floor(baseSize * this.config.sizeMult);
                this.value = Math.floor(baseValue * this.config.valueMult);
                
                // Slow effect
                this.slowedUntil = 0;
                this.slowAmount = 1;
            }

            applySlow(amount, duration) {
                this.slowAmount = amount;
                this.slowedUntil = Date.now() + duration;
            }

            update() {
                // Check if slow expired
                if (Date.now() > this.slowedUntil) {
                    this.slowAmount = 1;
                }
                
                // Apply speed with slow effect and game speed
                let currentSpeed = this.speed * this.slowAmount * gameSpeed;
                
                // Straight horizontal path toward base - strict lane movement
                this.x += currentSpeed;
                // Keep Y position locked to lane
                this.y = lane;

                // Check if reached base
                if (this.x > base.x - 40) {
                    gameState.baseHealth -= 10;
                    updateUI();
                    return false;
                }

                // Check if dead
                if (this.health <= 0) {
                    gameState.score += this.value;
                    gameState.resources += Math.floor(this.value / 2);
                    createExplosion(this.x, this.y, 2);
                    updateUI();
                    return false;
                }

                return true;
            }

            draw() {
                // Slow effect indicator
                if (this.slowAmount < 1) {
                    ctx.strokeStyle = 'rgba(170, 68, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enemy body - use type colors
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.config.color);
                gradient.addColorStop(0.5, this.config.colorDark);
                gradient.addColorStop(1, '#220000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Spikes - different count per type
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = this.type === 'tank' || this.type === 'boss' ? 4 : 3;
                let spikeCount = this.type === 'scout' ? 4 : this.type === 'boss' ? 12 : this.type === 'tank' ? 8 : 6;
                for (let i = 0; i < spikeCount; i++) {
                    let angle = (i / spikeCount) * Math.PI * 2 + Date.now() / 1000;
                    let spikeLength = this.type === 'boss' ? 15 : 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * this.size, this.y + Math.sin(angle) * this.size);
                    ctx.lineTo(this.x + Math.cos(angle) * (this.size + spikeLength), this.y + Math.sin(angle) * (this.size + spikeLength));
                    ctx.stroke();
                }

                // Health bar
                let healthPercent = this.health / this.maxHealth;
                let barWidth = this.size * 2;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth, 6);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffaa00' : '#ff4444';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth * healthPercent, 6);
                
                // Type label for tanks and bosses
                if (this.type === 'tank' || this.type === 'boss') {
                    ctx.fillStyle = this.type === 'boss' ? '#ff0066' : 'rgba(255,255,255,0.7)';
                    ctx.font = this.type === 'boss' ? 'bold 12px sans-serif' : 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.type.toUpperCase(), this.x, this.y - this.size - 16);
                }
                
                // Boss glow effect
                if (this.type === 'boss') {
                    ctx.strokeStyle = `rgba(255, 0, 102, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx * gameSpeed;
                this.y += this.vy * gameSpeed;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life -= gameSpeed;
                return this.life > 0;
            }

            draw() {
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createExplosion(x, y, intensity = 1) {
            const colors = ['rgb(255, 136, 0)', 'rgb(255, 200, 0)', 'rgb(255, 68, 68)', 'rgb(255, 255, 255)'];
            for (let i = 0; i < 8 * intensity; i++) {
                particles.push(new Particle(x, y, colors[Math.floor(Math.random() * colors.length)]));
            }
        }

        function spawnWave() {
            // Wave 1 = 4 enemies, then +5 per wave (wave 2 = 9, wave 3 = 14, etc.)
            let enemyCount = 4 + (gameState.wave - 1) * 5;
            gameState.waveSpawning = true;
            
            // Boss wave every 5 waves
            let isBossWave = gameState.wave % 5 === 0;
            
            for (let i = 0; i < enemyCount; i++) {
                // Determine enemy type based on wave and randomness
                let type = 'normal';
                let roll = Math.random();
                
                // Scouts appear from wave 2+
                if (gameState.wave >= 2 && roll < 0.3) {
                    type = 'scout';
                }
                // Tanks appear from wave 3+
                else if (gameState.wave >= 3 && roll > 0.85) {
                    type = 'tank';
                }
                
                // Slower spawn rate - more time between enemies
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, type));
                    }
                    // Mark spawning complete after last enemy
                    if (i === enemyCount - 1) {
                        gameState.waveSpawning = false;
                    }
                }, i * (1200 - Math.min(gameState.wave * 40, 600)));
            }
            
            // Spawn boss at the end of boss waves
            if (isBossWave) {
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.gameOver) {
                        enemies.push(new Enemy(gameState.wave, 'boss'));
                        showBossWarning();
                    }
                }, enemyCount * (1200 - Math.min(gameState.wave * 40, 600)) + 1000);
            }
            
            showWaveAnnouncement(isBossWave);
        }
        
        function showBossWarning() {
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.textContent = '‚ö†Ô∏è BOSS INCOMING! ‚ö†Ô∏è';
            document.getElementById('gameContainer').appendChild(warning);
            setTimeout(() => warning.remove(), 2000);
        }

        let waveBreakTimer = null;
        let breakTimeLeft = 0;

        function startWaveBreak() {
            breakTimeLeft = 10;
            updateBreakDisplay();
            document.getElementById('waveBreak').style.display = 'flex';
            
            waveBreakTimer = setInterval(() => {
                breakTimeLeft--;
                updateBreakDisplay();
                
                if (breakTimeLeft <= 0) {
                    clearInterval(waveBreakTimer);
                    document.getElementById('waveBreak').style.display = 'none';
                    gameState.wave++;
                    spawnWave();
                }
            }, 1000);
        }

        function updateBreakDisplay() {
            document.getElementById('breakTimer').textContent = breakTimeLeft;
            document.getElementById('nextWaveNum').textContent = gameState.wave + 1;
            // Show how many enemies next wave
            let nextEnemyCount = 4 + gameState.wave * 5;
            document.getElementById('nextEnemyCount').textContent = nextEnemyCount;
        }

        function skipBreak() {
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
                document.getElementById('waveBreak').style.display = 'none';
                gameState.wave++;
                spawnWave();
            }
        }

        function showWaveAnnouncement(isBossWave = false) {
            const announcement = document.createElement('div');
            announcement.className = 'wave-announcement';
            if (isBossWave) {
                announcement.innerHTML = `WAVE ${gameState.wave}<br><span style="color: #ff0066; font-size: 24px;">‚ö†Ô∏è BOSS WAVE ‚ö†Ô∏è</span>`;
            } else {
                announcement.textContent = `WAVE ${gameState.wave}`;
            }
            document.getElementById('gameContainer').appendChild(announcement);
            setTimeout(() => announcement.remove(), 2000);
        }

        function showPopup(x, y, message, isError = false) {
            const popup = document.createElement('div');
            popup.className = 'popup-message' + (isError ? ' error' : '');
            popup.textContent = message;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        function handleClick(e) {
            if (!gameState.isPlaying || gameState.gameOver) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicked on existing turret
            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 30) {
                    selectedTurret = turret;
                    showUpgradePanel(turret);
                    return;
                }
            }

            // Close upgrade panel if clicking elsewhere
            closeUpgradePanel();

            // Check placement validity
            if (x > canvas.width - 150) {
                showPopup(x, y - 20, "Too close to base!", true);
                return;
            }

            for (let turret of turrets) {
                if (Math.hypot(x - turret.x, y - turret.y) < 60) {
                    showPopup(x, y - 20, "Too close to turret!", true);
                    return;
                }
            }

            if (gameState.resources >= turretTypes[selectedTurretType].cost) {
                turrets.push(new Turret(x, y, selectedTurretType));
                gameState.resources -= turretTypes[selectedTurretType].cost;
                showPopup(x, y - 20, `${turretTypes[selectedTurretType].name} deployed!`);
                updateUI();
            } else {
                showPopup(x, y - 20, `Need ${turretTypes[selectedTurretType].cost} resources!`, true);
            }
        }

        function selectTurretType(type) {
            selectedTurretType = type;
            // Update UI
            document.querySelectorAll('.turret-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.type === type) {
                    opt.classList.add('selected');
                }
            });
            updateUI();
        }

        function showUpgradePanel(turret) {
            const panel = document.getElementById('upgradePanel');
            const stats = document.getElementById('turretStats');
            const btn = document.getElementById('upgradeBtn');
            const sellBtn = document.getElementById('sellBtn');
            
            stats.innerHTML = `${turret.config.name} Lv${turret.level}/${turret.maxLevel} | DMG: ${turret.damage} | Range: ${turret.range}`;
            
            const cost = turret.getUpgradeCost();
            if (cost) {
                btn.textContent = `Upgrade (${cost} üíé)`;
                btn.disabled = gameState.resources < cost;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
            
            // Sell button
            const sellValue = turret.getSellValue();
            sellBtn.textContent = `Sell (+${sellValue} üíé)`;
            
            panel.style.display = 'flex';
        }

        function sellTurret() {
            if (!selectedTurret) return;
            
            const sellValue = selectedTurret.getSellValue();
            gameState.resources += sellValue;
            
            // Remove turret from array
            const index = turrets.indexOf(selectedTurret);
            if (index > -1) {
                turrets.splice(index, 1);
            }
            
            showPopup(selectedTurret.x, selectedTurret.y - 30, `Sold for ${sellValue} üíé`);
            closeUpgradePanel();
            updateUI();
        }

        function toggleFastForward() {
            if (gameSpeed === 1) {
                gameSpeed = 2;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 2x';
                document.getElementById('fastForwardBtn').classList.add('active');
            } else {
                gameSpeed = 1;
                document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
                document.getElementById('fastForwardBtn').classList.remove('active');
            }
        }

        function useNuke() {
            if (gameState.resources < 200 || enemies.length === 0) return;
            
            gameState.resources -= 200;
            
            // Damage all enemies
            for (let enemy of enemies) {
                enemy.health -= 100;
                createExplosion(enemy.x, enemy.y, 2);
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'nuke-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 500);
            
            showPopup(canvas.width / 2, canvas.height / 2, 'üí• NUKE ACTIVATED!');
            updateUI();
        }

        function useFreeze() {
            if (gameState.resources < 100 || enemies.length === 0) return;
            
            gameState.resources -= 100;
            
            // Freeze all enemies for 3 seconds
            for (let enemy of enemies) {
                enemy.applySlow(0, 3000); // 0 = completely stopped
            }
            
            // Visual effect
            const effect = document.createElement('div');
            effect.className = 'freeze-effect';
            document.getElementById('gameContainer').appendChild(effect);
            setTimeout(() => effect.remove(), 3000);
            
            showPopup(canvas.width / 2, canvas.height / 2, '‚ùÑÔ∏è FREEZE ACTIVATED!');
            updateUI();
        }

        function closeUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            selectedTurret = null;
        }

        function upgradeTurret() {
            if (!selectedTurret) return;
            
            const cost = selectedTurret.getUpgradeCost();
            if (cost && gameState.resources >= cost) {
                gameState.resources -= cost;
                selectedTurret.upgrade();
                showPopup(selectedTurret.x, selectedTurret.y - 30, `Upgraded to Level ${selectedTurret.level}!`);
                showUpgradePanel(selectedTurret);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('resources').textContent = gameState.resources;
            document.getElementById('baseHealth').textContent = gameState.baseHealth;
            document.getElementById('enemiesLeft').textContent = enemies.length;

            // Health color
            const healthEl = document.getElementById('baseHealth');
            healthEl.className = 'stat-value';
            if (gameState.baseHealth <= 25) healthEl.classList.add('danger');
            else if (gameState.baseHealth <= 50) healthEl.classList.add('warning');

            // Cost panel - show selected turret
            const costPanel = document.getElementById('costPanel');
            const selectedConfig = turretTypes[selectedTurretType];
            document.getElementById('selectedTurretName').textContent = `${selectedConfig.name} - ${selectedConfig.cost} üíé`;
            costPanel.className = gameState.resources >= selectedConfig.cost ? 'can-afford' : 'cannot-afford';
            
            // Update turret selection buttons affordability
            document.querySelectorAll('.turret-option').forEach(opt => {
                const type = opt.dataset.type;
                const cost = turretTypes[type].cost;
                if (gameState.resources < cost) {
                    opt.classList.add('cannot-afford');
                } else {
                    opt.classList.remove('cannot-afford');
                }
            });
            
            // Update ability buttons
            document.getElementById('nukeBtn').disabled = gameState.resources < 200;
            document.getElementById('freezeBtn').disabled = gameState.resources < 100;
        }

        function drawStars() {
            for (let star of stars) {
                star.x -= star.speed;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
                
                let twinkle = 0.5 + Math.sin(Date.now() / 500 + star.brightness * 10) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLanes() {
            // Draw single lane path so player knows where enemies will travel
            let y = lane;
            
            // Lane background stripe
            ctx.fillStyle = 'rgba(255, 100, 100, 0.08)';
            ctx.fillRect(0, y - 30, canvas.width - 100, 60);
            
            // Lane guide line (dashed)
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.25)';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width - 100, y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Lane edges
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, y - 30);
            ctx.lineTo(canvas.width - 100, y - 30);
            ctx.moveTo(0, y + 30);
            ctx.lineTo(canvas.width - 100, y + 30);
            ctx.stroke();
        }

        function drawBase() {
            // Base glow
            const glow = ctx.createRadialGradient(base.x, base.y, 0, base.x, base.y, 80);
            glow.addColorStop(0, 'rgba(0, 136, 255, 0.3)');
            glow.addColorStop(1, 'rgba(0, 136, 255, 0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 80, 0, Math.PI * 2);
            ctx.fill();

            // Base structure
            const gradient = ctx.createLinearGradient(base.x - 40, 0, base.x + 40, 0);
            gradient.addColorStop(0, '#0066aa');
            gradient.addColorStop(0.5, '#0088ff');
            gradient.addColorStop(1, '#0066aa');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(base.x - 30, base.y + 50);
            ctx.lineTo(base.x - 40, base.y);
            ctx.lineTo(base.x - 30, base.y - 50);
            ctx.lineTo(base.x + 20, base.y - 40);
            ctx.lineTo(base.x + 30, base.y);
            ctx.lineTo(base.x + 20, base.y + 40);
            ctx.closePath();
            ctx.fill();

            // Shield effect
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.3 + Math.sin(Date.now() / 300) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(base.x, base.y, 55, 0, Math.PI * 2);
            ctx.stroke();

            // Health indicator
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', base.x, base.y + 70);
        }

        function gameLoop(timestamp) {
            // Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Background
            drawStars();
            drawLanes();

            if (gameState.isPlaying && !gameState.gameOver) {
                // Update
                turrets.forEach(t => t.update(timestamp));
                projectiles = projectiles.filter(p => p.update());
                enemies = enemies.filter(e => e.update());
                particles = particles.filter(p => p.update());

                // Check wave complete - start break timer instead of immediate spawn
                if (enemies.length === 0 && gameState.isPlaying && !gameState.waveSpawning && document.getElementById('waveBreak').style.display !== 'flex') {
                    startWaveBreak();
                }

                // Check game over
                if (gameState.baseHealth <= 0) {
                    gameState.gameOver = true;
                    document.getElementById('finalScore').textContent = gameState.score;
                    document.getElementById('wavesSurvived').textContent = gameState.wave - 1;
                    document.getElementById('gameOver').style.display = 'flex';
                }

                updateUI();
            }

            // Draw
            drawBase();
            turrets.forEach(t => t.draw());
            enemies.forEach(e => e.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = {
                isPlaying: true,
                score: 0,
                resources: 100,
                wave: 1,
                baseHealth: 100,
                gameOver: false,
                waveSpawning: false
            };
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            // Reset game speed
            gameSpeed = 1;
            document.getElementById('fastForwardBtn').textContent = '‚ñ∂‚ñ∂ 1x';
            document.getElementById('fastForwardBtn').classList.remove('active');
            
            // Clear any existing break timer
            if (waveBreakTimer) {
                clearInterval(waveBreakTimer);
            }
            document.getElementById('waveBreak').style.display = 'none';
            
            initStars();
            document.getElementById('startScreen').style.display = 'none';
            spawnWave();
            updateUI();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);
        initStars();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

        /* =================================
           CSS VARIABLES & MODERN DESIGN SYSTEM
        ================================= */
        :root {
            --bg-primary: #000814;
            --bg-secondary: #001427;
            --accent-neon: #00e5a8;
            --accent-warning: #ff6b35;
            --accent-danger: #ff4d6d;
            --text-primary: #e6f7f3;
            --text-muted: #9aa6b2;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --neon-glow: 0 0 20px var(--accent-neon);
            --shadow-depth: 0 8px 40px rgba(0, 0, 0, 0.6);
        }

        /* =================================
           GLOBAL STYLES & LAYOUT
        ================================= */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #001021 0%, var(--bg-primary) 60%);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1000px, 95vw);
            height: min(700px, 85vh);
            background: linear-gradient(180deg, var(--bg-secondary), rgba(0, 0, 0, 0.6));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: var(--shadow-depth), inset 0 1px 0 rgba(255, 255, 255, 0.02);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        #gameCanvas {
            display: block;
            background: transparent;
            width: 100%;
            height: 100%;
        }

        /* =================================
           UI OVERLAY STYLES
        ================================= */
        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 10;
            display: flex;
            gap: 16px;
            align-items: center;
            background: var(--glass);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: var(--text-muted);
        }

        #ui .stat {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #ui .stat span {
            color: var(--accent-neon);
            font-weight: 600;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        #startScreen h1 {
            font-size: clamp(28px, 5vw, 48px);
            color: var(--accent-neon);
            margin-bottom: 8px;
            text-shadow: var(--neon-glow);
            letter-spacing: 3px;
            font-weight: 700;
            text-transform: uppercase;
        }

        #startScreen .subtitle {
            color: var(--text-muted);
            margin-bottom: 30px;
            font-size: 16px;
            max-width: 500px;
            line-height: 1.6;
        }

        #startScreen button {
            font-size: 18px;
            padding: 14px 32px;
            background: linear-gradient(135deg, var(--accent-neon), #00b386);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startScreen button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 229, 168, 0.3);
        }

        #instructions {
            margin-top: 30px;
            text-align: left;
            max-width: 450px;
            background: var(--glass);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
        }

        #instructions h3 {
            color: var(--accent-neon);
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
        }

        #instructions p {
            margin: 8px 0;
            color: var(--text-muted);
            font-size: 14px;
            line-height: 1.5;
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        #gameOver h1 {
            color: var(--accent-danger);
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--accent-danger);
        }

        #gameOver p {
            color: var(--text-muted);
            font-size: 18px;
            margin: 10px 0;
        }

        #gameOver button {
            font-size: 16px;
            padding: 12px 28px;
            background: var(--accent-danger);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        #gameOver button:hover {
            background: #e43d5a;
            transform: translateY(-2px);
        }

        .wave-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: var(--accent-neon);
            z-index: 50;
            display: none;
            text-shadow: var(--neon-glow);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 2s ease-in-out;
        }

        #costIndicator {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 10;
            background: var(--glass);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: var(--text-muted);
        }

        .cost-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cost-icon {
            font-size: 16px;
        }

        .cost-text {
            color: var(--text-primary);
        }

        .cost-text strong {
            color: var(--accent-neon);
            font-weight: 600;
        }

        #costIndicator.insufficient {
            border-color: var(--accent-danger);
        }

        #costIndicator.insufficient .cost-text {
            color: var(--accent-danger);
        }

        #upgradePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            background: var(--glass);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(15px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            min-width: 300px;
            box-shadow: var(--shadow-depth);
        }

        .upgrade-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            color: var(--accent-warning);
            font-weight: 600;
            font-size: 16px;
        }

        .upgrade-icon {
            font-size: 20px;
        }

        .upgrade-stats {
            margin-bottom: 20px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .upgrade-stats div {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .upgrade-stats span {
            color: var(--accent-neon);
            font-weight: 600;
        }

        .upgrade-actions {
            display: flex;
            gap: 12px;
        }

        .upgrade-actions button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
        }

        #upgradeBtn {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }

        #upgradeBtn:hover:not(:disabled) {
            background: #e55a2b;
            transform: translateY(-1px);
        }

        #upgradeBtn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }

        .upgrade-actions button:last-child {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-muted);
        }

        .upgrade-actions button:last-child:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* =================================
           RESPONSIVE DESIGN
        ================================= */
        @media (max-width: 768px) {
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }

            #ui {
                font-size: 12px;
                gap: 12px;
                padding: 8px 12px;
            }

            #startScreen h1 {
                font-size: 32px;
            }

            #instructions {
                max-width: 90%;
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <!-- UI Overlay -->
        <div id="ui">
            <div class="stat">Wave: <span id="wave">1</span></div>
            <div class="stat">Score: <span id="score">0</span></div>
            <div class="stat">Resources: <span id="resources">100</span></div>
            <div class="stat">Base Health: <span id="baseHealth">100</span></div>
            <div class="stat">Enemies Left: <span id="enemiesLeft">0</span></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen">
            <h1>Space Defense Command</h1>
            <p class="subtitle">Strategic tower defense in the depths of space. Place turrets, defend your base, survive the alien invasion.</p>
            <button onclick="startGame()">LAUNCH DEFENSE</button>
            <div id="instructions">
                <h3>Mission Briefing</h3>
                <p>üéØ Click empty spots to place turrets (Cost: 50 resources)</p>
                <p>‚ö° Click existing turrets to upgrade them (3 levels max)</p>
                <p>üöÄ Turrets automatically target and fire homing projectiles</p>
                <p>üõ°Ô∏è Protect your base from alien invasion!</p>
                <p>‚≠ê Each wave gets harder - plan and upgrade your defense!</p>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOver">
            <h1>DEFENSE BREACHED</h1>
            <p>Your base has fallen to the alien invasion</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="wavesSurvived">0</span></p>
            <button onclick="restartGame()">REDEPLOY DEFENSES</button>
        </div>

        <!-- Wave Complete Message -->
        <div class="wave-complete" id="waveComplete">WAVE COMPLETE!</div>

        <!-- Cost Indicator -->
        <div id="costIndicator">
            <div class="cost-info">
                <span class="cost-icon">üéØ</span>
                <span class="cost-text">Turret Cost: <strong>50</strong> resources</span>
            </div>
        </div>

        <!-- Upgrade Panel -->
        <div id="upgradePanel" style="display: none;">
            <div class="upgrade-header">
                <span class="upgrade-icon">‚ö°</span>
                <span>Upgrade Turret</span>
            </div>
            <div id="upgradeInfo" class="upgrade-stats">
                <div>Level: <span id="turretLevel">1/3</span></div>
                <div>Damage: <span id="turretDamage">25</span></div>
                <div>Range: <span id="turretRange">150</span></div>
                <div>Fire Rate: <span id="turretFireRate">1.3/sec</span></div>
            </div>
            <div class="upgrade-actions">
                <button id="upgradeBtn" onclick="upgradeSelectedTurret()">Upgrade (60)</button>
                <button onclick="hideUpgradePanel()">Close</button>
            </div>
        </div>
    </div>

    <script>
        /* =================================
           GAME STATE AND CONFIGURATION
        ================================= */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            resources: 100,
            wave: 1,
            baseHealth: 100,
            gameOver: false
        };

        // Game objects arrays
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        
        // Upgrade system
        let selectedTurret = null;

        // Enemy path (curved path from left to right)
        const enemyPath = [
            {x: -50, y: 350},
            {x: 100, y: 350},
            {x: 200, y: 200},
            {x: 400, y: 150},
            {x: 600, y: 300},
            {x: 800, y: 400},
            {x: 1000, y: 350},
            {x: 1100, y: 350}
        ];

        // Wave management
        let currentWave = [];
        let waveComplete = false;
        let enemiesSpawned = 0;
        let nextSpawnTime = 0;

        /* =================================
           GAME CLASSES
        ================================= */

        class Turret {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.level = 1;
                this.maxLevel = 3;
                
                // Base stats
                this.baseRange = 150;
                this.baseDamage = 25;
                this.baseFireRate = 800;
                
                // Update stats based on level
                this.updateStats();
                
                this.lastShot = 0;
                this.target = null;
                this.angle = 0;
            }

            updateStats() {
                // Scale stats with level
                this.range = this.baseRange + (this.level - 1) * 25;
                this.damage = this.baseDamage + (this.level - 1) * 15;
                this.fireRate = Math.max(300, this.baseFireRate - (this.level - 1) * 150);
            }

            getUpgradeCost() {
                if (this.level >= this.maxLevel) return 0;
                return 40 + (this.level * 20); // Level 2: 60, Level 3: 80
            }

            canUpgrade() {
                return this.level < this.maxLevel && gameState.resources >= this.getUpgradeCost();
            }

            upgrade() {
                if (this.level < this.maxLevel && gameState.resources >= this.getUpgradeCost()) {
                    gameState.resources -= this.getUpgradeCost();
                    this.level++;
                    this.updateStats();
                    return true;
                }
                return false;
            }

            isClicked(mouseX, mouseY) {
                let distance = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                return distance <= 25;
            }

            update(timestamp) {
                // Find nearest enemy in range
                this.target = null;
                let closestDistance = this.range;
                
                for (let enemy of enemies) {
                    let distance = Math.sqrt(
                        Math.pow(enemy.x - this.x, 2) + 
                        Math.pow(enemy.y - this.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        this.target = enemy;
                        closestDistance = distance;
                    }
                }

                // Aim at target
                if (this.target) {
                    this.angle = Math.atan2(
                        this.target.y - this.y,
                        this.target.x - this.x
                    );

                    // Shoot if ready
                    if (timestamp - this.lastShot > this.fireRate) {
                        this.shoot(timestamp);
                        this.lastShot = timestamp;
                    }
                }
            }

            shoot(timestamp) {
                if (!this.target) return;
                
                projectiles.push(new Projectile(
                    this.x, this.y, 
                    this.target,
                    this.damage,
                    this.level
                ));
            }

            draw() {
                // Show range when selected
                if (this === selectedTurret) {
                    ctx.strokeStyle = 'rgba(0, 229, 168, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw turret base with level-based size
                const baseSize = 22 + (this.level - 1) * 4;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, baseSize);
                
                // Level-based colors
                if (this.level >= 3) {
                    gradient.addColorStop(0, '#66ddff');
                    gradient.addColorStop(0.6, '#0099cc');
                    gradient.addColorStop(1, '#006699');
                } else if (this.level >= 2) {
                    gradient.addColorStop(0, '#ff8800');
                    gradient.addColorStop(0.6, '#cc6600');
                    gradient.addColorStop(1, '#994400');
                } else {
                    gradient.addColorStop(0, '#00e5a8');
                    gradient.addColorStop(0.6, '#00b386');
                    gradient.addColorStop(1, '#008866');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, baseSize, 0, Math.PI * 2);
                ctx.fill();

                // Add inner glow
                ctx.fillStyle = this.level >= 3 ? 'rgba(102, 221, 255, 0.4)' : 
                               this.level >= 2 ? 'rgba(255, 136, 0, 0.4)' : 
                               'rgba(0, 229, 168, 0.4)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, baseSize - 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw upgrade level indicators
                if (this.level > 1) {
                    for (let i = 0; i < this.level - 1; i++) {
                        const angle = (i * Math.PI * 2) / (this.level - 1);
                        const indicatorX = this.x + Math.cos(angle) * (baseSize - 6);
                        const indicatorY = this.y + Math.sin(angle) * (baseSize - 6);
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw turret core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Draw turret barrel with level-based length
                const barrelLength = 30 + (this.level - 1) * 8;
                const barrelColor = this.level >= 3 ? '#66ddff' : 
                                  this.level >= 2 ? '#ff8800' : '#00e5a8';
                
                ctx.strokeStyle = barrelColor;
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * barrelLength,
                    this.y + Math.sin(this.angle) * barrelLength
                );
                ctx.stroke();

                // Add barrel highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class Enemy {
            constructor(health, speed, reward) {
                this.health = health;
                this.maxHealth = health;
                this.speed = speed;
                this.reward = reward;
                this.pathIndex = 0;
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.progress = 0;
            }

            update() {
                // Move along path
                if (this.pathIndex < enemyPath.length - 1) {
                    let current = enemyPath[this.pathIndex];
                    let next = enemyPath[this.pathIndex + 1];
                    
                    let dx = next.x - current.x;
                    let dy = next.y - current.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    this.progress += this.speed / distance;
                    
                    if (this.progress >= 1) {
                        this.pathIndex++;
                        this.progress = 0;
                    }
                    
                    if (this.pathIndex < enemyPath.length - 1) {
                        current = enemyPath[this.pathIndex];
                        next = enemyPath[this.pathIndex + 1];
                        
                        this.x = current.x + (next.x - current.x) * this.progress;
                        this.y = current.y + (next.y - current.y) * this.progress;
                    }
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            reachedEnd() {
                return this.pathIndex >= enemyPath.length - 1;
            }

            draw() {
                // Draw enemy body with health-based coloring
                let healthPercent = this.health / this.maxHealth;
                let bodyColor = healthPercent > 0.5 ? '#ff6b35' : '#ff4d6d';
                
                // Enemy body gradient
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 18);
                gradient.addColorStop(0, bodyColor);
                gradient.addColorStop(0.7, '#cc4420');
                gradient.addColorStop(1, '#aa3318');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
                ctx.fill();

                // Add enemy glow
                ctx.fillStyle = `rgba(255, 107, 53, ${0.3 + healthPercent * 0.4})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                ctx.fill();

                // Draw enemy core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw sleek health bar
                let barWidth = 32;
                let barHeight = 4;
                
                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - barWidth/2, this.y - 28, barWidth, barHeight);
                
                // Health bar fill with gradient
                const healthGradient = ctx.createLinearGradient(
                    this.x - barWidth/2, this.y - 28,
                    this.x - barWidth/2 + barWidth * healthPercent, this.y - 28
                );
                healthGradient.addColorStop(0, healthPercent > 0.6 ? '#00e5a8' : '#ff6b35');
                healthGradient.addColorStop(1, healthPercent > 0.6 ? '#00b386' : '#ff4d6d');
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(
                    this.x - barWidth/2, 
                    this.y - 28, 
                    barWidth * healthPercent, 
                    barHeight
                );
                
                // Health bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - barWidth/2, this.y - 28, barWidth, barHeight);
            }
        }

        class Projectile {
            constructor(x, y, target, damage, level = 1) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.level = level;
                this.speed = 8 + (level - 1) * 2;
                this.homing = 0.15; // How aggressively it tracks
            }

            update() {
                if (!this.target || !enemies.includes(this.target)) {
                    return false; // Remove projectile if target is gone
                }

                // Calculate homing trajectory
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    // Hit the target
                    if (this.target.takeDamage(this.damage)) {
                        // Enemy destroyed
                        gameState.score += this.target.reward;
                        gameState.resources += this.target.reward;
                        
                        // Create explosion particles (more for higher level)
                        const particleCount = 6 + this.level * 2;
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new Particle(
                                this.target.x, this.target.y,
                                Math.random() * Math.PI * 2,
                                2 + Math.random() * (2 + this.level),
                                this.level
                            ));
                        }
                        
                        // Remove enemy
                        let index = enemies.indexOf(this.target);
                        if (index > -1) enemies.splice(index, 1);
                    }
                    return false; // Remove projectile
                }

                // Homing movement
                dx /= distance;
                dy /= distance;
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                return true; // Keep projectile
            }

            draw() {
                // Enhanced projectile based on level
                const size = 6 + this.level * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
                
                if (this.level >= 3) {
                    // Level 3: Blue energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#66ddff');
                    gradient.addColorStop(1, 'rgba(102, 221, 255, 0)');
                } else if (this.level >= 2) {
                    // Level 2: Orange energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ff8800');
                    gradient.addColorStop(1, 'rgba(255, 136, 0, 0)');
                } else {
                    // Level 1: Yellow energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ffff00');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                }
                
                // Outer glow
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Core projectile
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(2, size/2), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, angle, speed, level = 1) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 20 + level * 8;
                this.maxLife = this.life;
                this.level = level;
                this.size = 1 + level;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }

            draw() {
                let alpha = this.life / this.maxLife;
                let currentSize = this.size * (1 + (1 - alpha) * 2); // Particles grow as they fade
                
                // Create gradient particle with level-based colors
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentSize);
                
                if (this.level >= 3) {
                    // Level 3: Blue explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(102, 221, 255, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(0, 150, 255, ${alpha * 0.3})`);
                } else if (this.level >= 2) {
                    // Level 2: Orange explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(255, 136, 0, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 68, 0, ${alpha * 0.3})`);
                } else {
                    // Level 1: Yellow explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(255, 255, 0, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 107, 53, ${alpha * 0.3})`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /* =================================
           GAME MECHANICS
        ================================= */

        function generateWave(waveNumber) {
            let wave = [];
            let enemyCount = 5 + waveNumber * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                let enemyType = Math.random();
                let enemy;
                
                if (enemyType < 0.6) {
                    // Basic enemy
                    enemy = new Enemy(30 + waveNumber * 10, 1, 10);
                } else if (enemyType < 0.9) {
                    // Fast enemy
                    enemy = new Enemy(20 + waveNumber * 5, 2, 15);
                } else {
                    // Tank enemy
                    enemy = new Enemy(80 + waveNumber * 20, 0.5, 25);
                }
                
                wave.push(enemy);
            }
            
            return wave;
        }

        function spawnWave() {
            currentWave = generateWave(gameState.wave);
            enemiesSpawned = 0;
            nextSpawnTime = performance.now();
            waveComplete = false;
        }

        function checkWaveComplete() {
            if (!waveComplete && currentWave.length === 0 && enemies.length === 0) {
                waveComplete = true;
                gameState.wave++;
                gameState.resources += 50; // Wave completion bonus
                
                // Show wave complete message
                document.getElementById('waveComplete').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('waveComplete').style.display = 'none';
                    spawnWave(); // Start next wave
                }, 2000);
            }
        }

        function handleClick(event) {
            if (!gameState.isPlaying || gameState.gameOver) return;
            
            let rect = canvas.getBoundingClientRect();
            let x = (event.clientX - rect.left) * (canvas.width / rect.width);
            let y = (event.clientY - rect.top) * (canvas.height / rect.height);
            
            // First check if clicking on an existing turret to upgrade
            for (let turret of turrets) {
                if (turret.isClicked(x, y)) {
                    selectTurret(turret);
                    return;
                }
            }
            
            // If not clicking on turret, try to place new one
            if (gameState.resources >= 50) {
                // Check if too close to existing turrets
                let canPlace = true;
                
                for (let turret of turrets) {
                    let distance = Math.sqrt((x - turret.x) ** 2 + (y - turret.y) ** 2);
                    if (distance < 45) {
                        canPlace = false;
                        break;
                    }
                }
                
                // Check if too close to path (more lenient)
                if (canPlace) {
                    for (let point of enemyPath) {
                        let distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        if (distance < 45) {
                            canPlace = false;
                            break;
                        }
                    }
                }
                
                // Check boundaries (more lenient)
                if (canPlace && x > 30 && x < canvas.width - 30 && y > 30 && y < canvas.height - 30) {
                    turrets.push(new Turret(x, y));
                    gameState.resources -= 50;
                    hideUpgradePanel(); // Close any open upgrade panel
                } else {
                    showMessage("Invalid placement location!");
                }
            } else {
                showMessage("Need 50 resources to place turret!");
            }
        }

        function selectTurret(turret) {
            selectedTurret = turret;
            showUpgradePanel();
        }

        function showUpgradePanel() {
            if (!selectedTurret) return;
            
            const panel = document.getElementById('upgradePanel');
            const upgradeBtn = document.getElementById('upgradeBtn');
            
            // Update stats display
            document.getElementById('turretLevel').textContent = `${selectedTurret.level}/${selectedTurret.maxLevel}`;
            document.getElementById('turretDamage').textContent = selectedTurret.damage;
            document.getElementById('turretRange').textContent = selectedTurret.range;
            document.getElementById('turretFireRate').textContent = `${(1000 / selectedTurret.fireRate).toFixed(1)}/sec`;
            
            // Update upgrade button
            const cost = selectedTurret.getUpgradeCost();
            const canUpgrade = selectedTurret.canUpgrade();
            
            upgradeBtn.disabled = !canUpgrade;
            upgradeBtn.textContent = canUpgrade ? `Upgrade (${cost})` : 'Max Level';
            
            panel.style.display = 'block';
        }

        function hideUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            selectedTurret = null;
        }

        function upgradeSelectedTurret() {
            if (selectedTurret && selectedTurret.upgrade()) {
                showUpgradePanel(); // Refresh the panel
                showMessage(`Turret upgraded to level ${selectedTurret.level}!`, true);
            }
        }

        function showMessage(text, isPositive = false) {
            // Create temporary message element
            const message = document.createElement('div');
            message.textContent = text;
            
            const messageColor = isPositive ? 'var(--accent-neon)' : 'var(--accent-danger)';
            
            message.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: ${messageColor};
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: 600;
                z-index: 60;
                animation: messagePopup 2s ease-out forwards;
            `;
            
            // Add keyframe animation
            if (!document.querySelector('#messageStyle')) {
                const style = document.createElement('style');
                style.id = 'messageStyle';
                style.textContent = `
                    @keyframes messagePopup {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.getElementById('gameContainer').appendChild(message);
            
            // Remove message after animation
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 2000);
        }

        /* =================================
           GAME LOOP AND RENDERING
        ================================= */

        function gameLoop(timestamp) {
            if (!gameState.isPlaying || gameState.gameOver) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw starfield background
            drawBackground();
            
            // Draw enemy path
            drawPath();
            
            // Spawn enemies from current wave
            if (currentWave.length > 0 && timestamp >= nextSpawnTime) {
                enemies.push(currentWave.shift());
                nextSpawnTime = timestamp + 1000; // 1 second between spawns
            }

            // Update turrets
            for (let turret of turrets) {
                turret.update(timestamp);
                turret.draw();
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.update();
                enemy.draw();
                
                if (enemy.reachedEnd()) {
                    gameState.baseHealth -= 20;
                    enemies.splice(i, 1);
                    
                    if (gameState.baseHealth <= 0) {
                        endGame();
                    }
                }
            }

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].update()) {
                    projectiles.splice(i, 1);
                } else {
                    projectiles[i].draw();
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw();
                }
            }

            // Check wave completion
            checkWaveComplete();
            
            // Update UI
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        function drawBackground() {
            // Create dynamic starfield
            ctx.fillStyle = '#ffffff';
            const time = performance.now() * 0.0001;
            
            for (let i = 0; i < 150; i++) {
                let x = (i * 137.5 + time * 10) % canvas.width;
                let y = (i * 177.3) % canvas.height;
                let twinkle = Math.sin(time * 3 + i) * 0.5 + 0.5;
                let alpha = 0.3 + twinkle * 0.7;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(x, y, 1, 1);
                
                // Add some larger stars
                if (i % 7 === 0) {
                    ctx.fillStyle = `rgba(0, 229, 168, ${alpha * 0.8})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
        }

        function drawPath() {
            // Draw enemy path with neon effect
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.2)';
            ctx.lineWidth = 50;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
            
            for (let i = 1; i < enemyPath.length; i++) {
                ctx.lineTo(enemyPath[i].x, enemyPath[i].y);
            }
            ctx.stroke();
            
            // Add glowing outline
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Add center line
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('resources').textContent = gameState.resources;
            document.getElementById('baseHealth').textContent = gameState.baseHealth;
            document.getElementById('enemiesLeft').textContent = enemies.length + currentWave.length;
            
            // Update cost indicator
            updateCostIndicator();
        }

        function updateCostIndicator() {
            const costIndicator = document.getElementById('costIndicator');
            const canAfford = gameState.resources >= 50;
            
            if (canAfford) {
                costIndicator.classList.remove('insufficient');
            } else {
                costIndicator.classList.add('insufficient');
            }
        }

        /* =================================
           GAME FLOW CONTROLS
        ================================= */

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.gameOver = false;
            spawnWave();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('wavesSurvived').textContent = gameState.wave - 1;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Reset game state
            gameState = {
                isPlaying: false,
                score: 0,
                resources: 100,
                wave: 1,
                baseHealth: 100,
                gameOver: false
            };
            
            // Clear game objects and upgrade state
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            currentWave = [];
            selectedTurret = null;
            
            // Hide all panels
            document.getElementById('upgradePanel').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);

        // Initialize the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
